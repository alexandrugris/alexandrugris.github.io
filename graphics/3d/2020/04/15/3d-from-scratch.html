<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>3D From Scratch</title>
  <meta name="description" content="This post is about implementing a 3D renderer from scratch, with no help from any graphics or maths library. It is implemented in pure JavaScript and it foll...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/graphics/3d/2020/04/15/3d-from-scratch.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">3D From Scratch</h1>
    <p class="post-meta"><time datetime="2020-04-15T09:15:16+02:00" itemprop="datePublished">Apr 15, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This post is about implementing a 3D renderer from scratch, with no help from any graphics or maths library. It is implemented in pure JavaScript and it follows roughly the first half of the excellent <a href="https://github.com/ssloy/tinyrenderer">tiny renderer</a> tutorial.</p>

<h3 id="the-end-result">The End Result</h3>

<p>We are going to build our software renderer to show this:</p>

<p><img src="https://alexandrugris.github.io/assets/tiny_1.png" alt="Head" /></p>

<p>The features our software renderer suppors are:</p>

<ul>
  <li>Model loading</li>
  <li>Phong (per pixel) lighting</li>
  <li>Triangle rasterization</li>
  <li>Model, camera, viewport transformations</li>
  <li>Wireframe rendering</li>
  <li>Texturing</li>
  <li>Z-Buffer</li>
  <li>Hidden face removal (backface culling)</li>
</ul>

<p>In addition to these, we will build a small and probably buggy maths library. All the code is included in this file: <a href="https://github.com/alexandrugris/webglfun/blob/master/basics-phong.html">basics-phong</a></p>

<h3 id="coordinate-systems">Coordinate Systems</h3>

<p>First and foremost, we will operate in the coordiate system with the z-axis pointing towards us, y-axis upwards and the x-axis rightwards.</p>

<p><img src="https://alexandrugris.github.io/assets/tiny_2.png" alt="Head" /></p>

<p>In addition to that, the model we will load is oriented towards z-axis. Also, by convention, we will consider triangles defined as counter-clockwise. This will help us later determine what is the front and what is the the back face of the triangle.</p>

<h3 id="loading-the-model">Loading the model</h3>

<p>The format for our model is standard: an indexed geometry, with a set of vertices, vertex normals and texture coordinates. Taking into consideration the counter-clockwise convention, here is how we define a quad.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">generateTexturedQuad</span><span class="p">(</span><span class="nx">mesh</span><span class="p">){</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nx">mesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>

    <span class="nx">mesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// all normals pointing towards the camera</span>
    <span class="c1">// in the case when 3d artists are not so kind,</span>
    <span class="c1">// you can recompute the normal vectors as an average of normals to all </span>
    <span class="c1">// facets incident to the vertex</span>

    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vnormals</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vnormals</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vnormals</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="nx">mesh</span><span class="p">.</span><span class="nx">vnormals</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">mesh</span><span class="p">.</span><span class="nx">worldTransform</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">mesh</span><span class="p">.</span><span class="nx">worldTransform</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
      <span class="nx">mesh</span><span class="p">.</span><span class="nx">worldTransform</span> <span class="o">=</span> <span class="nx">getIdentityMatrix</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="k">async</span> <span class="kd">function</span> <span class="nx">loadAsset</span><span class="p">(</span><span class="nx">diffuse</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="nx">myMesh</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">vertices</span><span class="p">:</span> <span class="p">[],</span>
      <span class="na">txcoords</span><span class="p">:</span> <span class="p">[],</span>
      <span class="na">vnormals</span><span class="p">:</span> <span class="p">[],</span>
      <span class="na">faces</span><span class="p">:</span> <span class="p">[],</span>
      <span class="na">diffuse</span><span class="p">:</span> <span class="nx">diffuse</span><span class="p">,</span>
      <span class="na">worldTransform</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> 
    <span class="p">};</span>

    <span class="nx">generateTexturedQuad</span><span class="p">(</span><span class="nx">myMesh</span><span class="p">);</span>
    
<span class="p">}</span>
</code></pre></div></div>

<p>Rendering this image also assumes the following are set:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">viewportTransform</span> <span class="o">=</span> <span class="nx">makeViewportTransform</span><span class="p">(</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
<span class="nx">projectionTransform</span> <span class="o">=</span> <span class="nx">getIdentityMatrix</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// no projection</span>
<span class="nx">cameraTransform</span> <span class="o">=</span> <span class="nx">makeIdentityCamMatrix</span><span class="p">();</span> <span class="c1">// no camera transformation</span>
</code></pre></div></div>

<p><img src="https://alexandrugris.github.io/assets/tiny_3.png" alt="Head" /></p>

<p>Since <code class="language-plaintext highlighter-rouge">projectionTransform</code> and <code class="language-plaintext highlighter-rouge">cameraTransform</code> are identity matrices, it means that the only transformation in place is the <code class="language-plaintext highlighter-rouge">viewportTransform</code>. This transform takes a coordiante space defined by the rectangle <code class="language-plaintext highlighter-rouge">x, y = [-1, 1], [-1, 1]</code>, with <code class="language-plaintext highlighter-rouge">y</code> pointing upwards, and transforms it to pixel on the screen coordiantes.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  * Transforms from [-1..1] to [0, w] and [h, 0] respectively.
  */</span>
<span class="kd">function</span> <span class="nx">makeViewportTransform</span><span class="p">(</span><span class="nx">viewportWidth</span><span class="p">,</span> <span class="nx">viewportHeight</span><span class="p">){</span>
    <span class="c1">// maintain aspect ratio</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="nx">viewportHeight</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">viewportWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nx">viewportHeight</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">viewportHeight</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
      <span class="c1">// spread a bit the numbers in the zbuffer (can be 1, but let's make it more discrete).</span>
      <span class="c1">// This is useful it we want to store the zbuffer as an integer instead of a float.</span>
      <span class="c1">// This would give the resolution of the depth buffer, mapping -1, 1]</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">]</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>It also transforms the z-buffer, but that is another chapter.</p>

<h3 id="wireframe-rendering">Wireframe Rendering</h3>

<p>Before we move to shading triangles, let’s first render our model in wireframe:</p>

<p><img src="https://alexandrugris.github.io/assets/tiny_4.png" alt="Head" /></p>

<p>For this, let’s look at our <code class="language-plaintext highlighter-rouge">generateImage</code> function and what it does if the <code class="language-plaintext highlighter-rouge">wireframe</code> parameter is set to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<p>The first step is to clear the background and the z-buffer. For wireframe rendering we don’t care about the z-buffer, but we do care about not drawing on top of an older image. So we put all pixels to green.</p>

<p>Another thing we care about is transforming our vertices from their world coordinates to their corresponding screen coordinates. For this we have a chain of transformations (matrix multiplications) we apply to each vertex. Transform <code class="language-plaintext highlighter-rouge">transformsWordToSreen</code> matrix takes a position in world coordinates and transforms it to <code class="language-plaintext highlighter-rouge">[x, y, z]</code> in screen space. We will use the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> to put the pixel on the screen and <code class="language-plaintext highlighter-rouge">z</code> to know if it is the topmost pixel and thus not hidden by another pixel. In <code class="language-plaintext highlighter-rouge">varrrayW</code> we keep the vertices in world coordinates, in <code class="language-plaintext highlighter-rouge">varray</code> in screen coordinates.</p>

<p>The loop that follows  generates the faces, the triangles of our model. As mentioned before, this is an indexed geometry so for each face we need to lookup by index the coresponding vertex in vertex array. We do the same for the normals and for the texture coordinates. These are not relevant for the wireframe rendering, but they are relevant for the next chapter when we shade the triangle. In the last loop, we draw the line.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">generateImage</span><span class="p">(</span><span class="nx">wireframe</span><span class="o">=</span><span class="kc">true</span><span class="p">){</span>

    <span class="c1">// clear background and Z buffer:</span>
    <span class="nx">clear</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">myMesh</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="kd">let</span> <span class="nx">triangles</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="cm">/* the following two lines are equivalent to the matrix transformation applied next
    let varray = myMesh.vertices.map(v=&gt;homogeneousTransform(vectorMultiply(projectionTransform, v)));
    varray = varray.map(v=&gt;homogeneousTransform(vectorMultiply(viewportTransform, v)));
     */</span>

    <span class="c1">//multiply first with transform because the vector appears later several times</span>
    <span class="kd">let</span> <span class="nx">transformsWorldToScreen</span> <span class="o">=</span> <span class="nx">chainMultiplyMatrix</span><span class="p">([</span><span class="nx">viewportTransform</span><span class="p">,</span> <span class="nx">projectionTransform</span><span class="p">,</span> <span class="nx">cameraTransform</span><span class="p">])</span>

    <span class="c1">// tranform the vertices to worldspace and then to screen</span>
    <span class="kd">let</span> <span class="nx">varrayW</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">homogeneousTransform</span><span class="p">(</span><span class="nx">vectorMultiply</span><span class="p">(</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">worldTransform</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">true</span><span class="p">)));</span>
    <span class="kd">let</span> <span class="nx">varray</span> <span class="o">=</span> <span class="nx">varrayW</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">homogeneousTransform</span><span class="p">(</span><span class="nx">vectorMultiply</span><span class="p">(</span><span class="nx">transformsWorldToScreen</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">true</span><span class="p">)));</span>

    <span class="c1">// transform the normals to world</span>
    <span class="c1">// isPosition == false so we don't translate</span>
    <span class="kd">let</span> <span class="nx">narrayW</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">vnormals</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">vectorMultiply</span><span class="p">(</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">worldTransform</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="kc">false</span><span class="p">)));</span>

     <span class="c1">// each face has 9 indices, only the 0, 3, 6 are vertex index</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>

       <span class="c1">// index in the vertex buffer</span>
       <span class="kd">let</span> <span class="nx">v0</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
       <span class="kd">let</span> <span class="nx">v1</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
       <span class="kd">let</span> <span class="nx">v2</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">6</span><span class="p">];</span>

       <span class="c1">// texture vertex index</span>
       <span class="kd">let</span> <span class="nx">tx0</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]];</span>
       <span class="kd">let</span> <span class="nx">tx1</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]];</span>
       <span class="kd">let</span> <span class="nx">tx2</span> <span class="o">=</span> <span class="nx">myMesh</span><span class="p">.</span><span class="nx">txcoords</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">7</span><span class="p">]];</span>

       <span class="c1">// vertex normal coords world space</span>
       <span class="kd">let</span> <span class="nx">vn0</span> <span class="o">=</span> <span class="nx">narrayW</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
       <span class="kd">let</span> <span class="nx">vn1</span> <span class="o">=</span> <span class="nx">narrayW</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">5</span><span class="p">]].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
       <span class="kd">let</span> <span class="nx">vn2</span> <span class="o">=</span> <span class="nx">narrayW</span><span class="p">[</span><span class="nx">myMesh</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">8</span><span class="p">]].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

       <span class="c1">// world space backface culling</span>
       <span class="kd">let</span> <span class="nx">faceNormal</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">crossProduct3</span><span class="p">(</span>
                      <span class="nx">subtractVector</span><span class="p">(</span><span class="nx">varrayW</span><span class="p">[</span><span class="nx">v2</span><span class="p">],</span> <span class="nx">varrayW</span><span class="p">[</span><span class="nx">v0</span><span class="p">]),</span>
                      <span class="nx">subtractVector</span><span class="p">(</span><span class="nx">varrayW</span><span class="p">[</span><span class="nx">v1</span><span class="p">],</span> <span class="nx">varrayW</span><span class="p">[</span><span class="nx">v0</span><span class="p">])</span>
                    <span class="p">));</span>

       <span class="kd">let</span> <span class="nx">visible</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">cameraDir</span><span class="p">,</span> <span class="nx">faceNormal</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>

       <span class="k">if</span><span class="p">(</span><span class="nx">visible</span> <span class="o">||</span> <span class="nx">wireframe</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">triangles</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">varray</span><span class="p">[</span><span class="nx">v0</span><span class="p">],</span> <span class="nx">varray</span><span class="p">[</span><span class="nx">v1</span><span class="p">],</span> <span class="nx">varray</span><span class="p">[</span><span class="nx">v2</span><span class="p">],</span> <span class="nx">vn0</span><span class="p">,</span> <span class="nx">vn1</span><span class="p">,</span> <span class="nx">vn2</span><span class="p">,</span> <span class="nx">tx0</span><span class="p">,</span> <span class="nx">tx1</span><span class="p">,</span> <span class="nx">tx2</span><span class="p">]);</span>
       <span class="p">}</span>

     <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">wireframe</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// TODO: remove duplicated lines, each line is drawn several times</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">triangles</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">triangles</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">drawLineV</span><span class="p">(</span><span class="nx">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">drawLineV</span><span class="p">(</span><span class="nx">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">drawLineV</span><span class="p">(</span><span class="nx">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">triangles</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">triangles</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="nx">drawTriangle</span><span class="p">(...</span><span class="nx">t</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="putpixel-and-line-drawing">PutPixel and Line Drawing</h3>

<p>As mentioned before, we don’t use any library for this demo. So we will implement our <code class="language-plaintext highlighter-rouge">drawLine</code> from scratch. Here it is how it goes. <code class="language-plaintext highlighter-rouge">screenBuffer</code> is our pixel matrix, organized as <code class="language-plaintext highlighter-rouge">RGBA</code>, each one byte in length.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">putPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">r</span><span class="o">=</span><span class="mh">0xff</span><span class="p">,</span> <span class="nx">g</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="nx">b</span><span class="o">=</span><span class="mh">0x00</span><span class="p">)</span> <span class="p">{</span>

  <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="o">*</span> <span class="nx">screenBuffer</span><span class="p">.</span><span class="nx">width</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

  <span class="nx">screenBuffer</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">r</span><span class="p">;</span>
  <span class="nx">screenBuffer</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">g</span><span class="p">;</span>
  <span class="nx">screenBuffer</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
  <span class="nx">screenBuffer</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

<span class="p">}</span>

<span class="kd">function</span> <span class="nx">drawLine</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="nx">y0</span><span class="p">,</span> <span class="nx">x1</span><span class="p">,</span> <span class="nx">y1</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// no line</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">x0</span> <span class="o">===</span> <span class="nx">x1</span> <span class="o">&amp;&amp;</span> <span class="nx">y1</span> <span class="o">===</span> <span class="nx">y0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// step</span>
  <span class="kd">let</span> <span class="nx">step</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">x0</span> <span class="o">-</span> <span class="nx">x1</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">y0</span> <span class="o">-</span> <span class="nx">y1</span><span class="p">));</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span> <span class="nx">step</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">x0</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="p">(</span><span class="nx">x1</span><span class="o">-</span><span class="nx">x0</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y0</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">*</span> <span class="p">(</span><span class="nx">y1</span><span class="o">-</span><span class="nx">y0</span><span class="p">);</span>
    <span class="nx">putPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="positions-and-directions-in-homogenous-coordinates">Positions and Directions in Homogenous Coordinates</h3>

<p>In order to be able to add a rotation, a translation and a projection in a single matrix multiplication step, we extend our <code class="language-plaintext highlighter-rouge">[x, y, z]</code> notion of a point in 3D space to <code class="language-plaintext highlighter-rouge">[x, y, z, w]</code>, which is congruent to the <code class="language-plaintext highlighter-rouge">[x/w, y/w, z/w, 1]</code>. This division is, in fact, a projection from the 4D space to the 3D space.</p>

<p>For orthogonal transformations, e.g. world-space transformations, vectors that represent points have <code class="language-plaintext highlighter-rouge">w == 1</code> and vectors that represent directions, defined as <code class="language-plaintext highlighter-rouge">p1 - p2</code>, have their <code class="language-plaintext highlighter-rouge">w == 0</code>.</p>

<h3 id="rendering-full-triangles">Rendering Full Triangles</h3>

<p>The most exciting part of our blog post is about rendering full triangles. Before we dive into the actual shading, let’s say the obvious that we only care about the triangles that are facing us. So we do a simple test. This test is called back-face culling. This is why counter-clockwise convetion for defining faces is important. If we weren’t following it, we’d have the normals oriented in the opposite direction.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// world space backface culling</span>
<span class="kd">let</span> <span class="nx">faceNormal</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">crossProduct3</span><span class="p">(</span>
                      <span class="nx">subtractVector</span><span class="p">(</span><span class="nx">varrayW</span><span class="p">[</span><span class="nx">v2</span><span class="p">],</span> <span class="nx">varrayW</span><span class="p">[</span><span class="nx">v0</span><span class="p">]),</span>
                      <span class="nx">subtractVector</span><span class="p">(</span><span class="nx">varrayW</span><span class="p">[</span><span class="nx">v1</span><span class="p">],</span> <span class="nx">varrayW</span><span class="p">[</span><span class="nx">v0</span><span class="p">])</span>
                      <span class="p">));</span>
<span class="kd">let</span> <span class="nx">visible</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">cameraDir</span><span class="p">,</span> <span class="nx">faceNormal</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>We compute the face normal using the <code class="language-plaintext highlighter-rouge">crossProduct3</code> function which, given a plane (3 points), computes a fourth vector perpendicular to the others. Then we check to see if the face normal and the <code class="language-plaintext highlighter-rouge">cameraDir</code> face in the opposite direction. This is what the <code class="language-plaintext highlighter-rouge">dot</code> product does.</p>

<p>The remaining part is covered in the <code class="language-plaintext highlighter-rouge">drawTriangle</code> function. The algorithm is very simple and it fits very well on massively parallel hardware as all triangles can be processed in parallel.</p>
<ul>
  <li>Find a bounding box for our triangle</li>
  <li>Shade each point from the bounding box only if inside the triangle</li>
</ul>

<p>The parameters for the function are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">v1, v2, v3</code> - triangle vertices transformed in screen space</li>
  <li><code class="language-plaintext highlighter-rouge">vn1, vn2, vn3</code> - vertex normals</li>
  <li><code class="language-plaintext highlighter-rouge">tx0, tx1, tx2</code> - texture coordinates for each vertex</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">drawTriangle</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">,</span> <span class="nx">vn1</span><span class="p">,</span> <span class="nx">vn2</span><span class="p">,</span> <span class="nx">vn3</span><span class="p">,</span> <span class="nx">tx0</span><span class="p">,</span> <span class="nx">tx1</span><span class="p">,</span> <span class="nx">tx2</span><span class="p">){</span>

    <span class="c1">// find the bounding box</span>
    <span class="kd">let</span> <span class="nx">bb</span> <span class="o">=</span> <span class="p">[</span><span class="nx">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
    <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="p">[</span><span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
      <span class="nx">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
      <span class="nx">bb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">bb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
      <span class="nx">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]));</span>
    <span class="p">}</span>

    <span class="c1">// check if the point is inside the triangle</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">bb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">bb</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">bb</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">bb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="nx">j</span><span class="o">++</span><span class="p">){</span>

        <span class="kd">const</span> <span class="nx">stu</span> <span class="o">=</span> <span class="nx">toBarycentricCoords</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">insideTriangle</span><span class="p">(</span><span class="nx">stu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">stu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">stu</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="p">{</span>

          <span class="c1">// interpolate over the z coord</span>
          <span class="kd">const</span> <span class="nx">pixelZWorld</span> <span class="o">=</span> <span class="nx">stu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nx">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">stu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nx">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">stu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="nx">v3</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
          <span class="kd">const</span> <span class="nx">zBufferIndex</span> <span class="o">=</span> <span class="nx">zBufferGetIdx</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="nx">pixelZWorld</span> <span class="o">&gt;=</span> <span class="nx">zBuffer</span><span class="p">[</span><span class="nx">zBufferIndex</span><span class="p">]){</span>
            <span class="nx">zBuffer</span><span class="p">[</span><span class="nx">zBufferIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pixelZWorld</span><span class="p">;</span>

            <span class="c1">// use again the barycentric coords to interpolate in the texture</span>
            <span class="c1">// matrix multiplication STU * [tx0, tx1, tx2]</span>
            <span class="kd">const</span> <span class="nx">tX</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">stu</span><span class="p">,</span> <span class="p">[</span><span class="nx">tx0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">tx1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">tx2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
            <span class="kd">const</span> <span class="nx">tY</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">stu</span><span class="p">,</span> <span class="p">[</span><span class="nx">tx0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">tx1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">tx2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]);</span>

            <span class="p">[</span><span class="nx">tr</span><span class="p">,</span> <span class="nx">tg</span><span class="p">,</span> <span class="nx">tb</span><span class="p">]</span> <span class="o">=</span> <span class="nx">getTextureData</span><span class="p">(</span><span class="nx">tX</span><span class="p">,</span> <span class="nx">tY</span><span class="p">);</span>

            <span class="c1">// interpolate normals (all in world space)</span>
            <span class="kd">const</span> <span class="nx">n0</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">stu</span><span class="p">,</span> <span class="p">[</span><span class="nx">vn1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">vn2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">vn3</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
            <span class="kd">const</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">stu</span><span class="p">,</span> <span class="p">[</span><span class="nx">vn1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">vn2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">vn3</span><span class="p">[</span><span class="mi">1</span><span class="p">]]);</span>
            <span class="kd">const</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">stu</span><span class="p">,</span> <span class="p">[</span><span class="nx">vn1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">vn2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">vn3</span><span class="p">[</span><span class="mi">2</span><span class="p">]]);</span>

            <span class="kd">let</span> <span class="nx">intensity</span> <span class="o">=</span> <span class="o">-</span><span class="nx">dot</span><span class="p">(</span><span class="nx">lightDir</span><span class="p">,</span> <span class="p">[</span><span class="nx">n0</span><span class="p">,</span> <span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">]);</span>
            <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">intensity</span><span class="p">);</span>

            <span class="nx">putPixel</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span> <span class="nx">tr</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span> <span class="nx">tg</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span> <span class="nx">tb</span><span class="p">);</span>
            <span class="c1">//putPixel(i, j, 255 * c , 255 * c , 255 * c ); // draw only the light intensity</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The most interesting point of this function is transforming each pixel inside the triangle to its <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a>. These coordiantes are 3 numbers, <code class="language-plaintext highlighter-rouge">s, t, u</code>, which give weights to how close the point is to each vertex. That is, <code class="language-plaintext highlighter-rouge">v1</code> would have barycentric coordiantes of <code class="language-plaintext highlighter-rouge">1, 0, 0</code>, <code class="language-plaintext highlighter-rouge">v2</code> would have its barycentric coordinates at <code class="language-plaintext highlighter-rouge">0, 1, 0</code> and <code class="language-plaintext highlighter-rouge">v3</code> at <code class="language-plaintext highlighter-rouge">0, 0, 1</code>. Obviously, <code class="language-plaintext highlighter-rouge">s + t + u == 1</code> and they allow linear interpolation for each pixel based on values stored in the face vertices. If a pixel is outside of our triangle, at least of its barycentric coordinates is negative.</p>

<p>So what do we do if the pixel is inside the triangle:</p>

<ul>
  <li>
    <p>We check if the pixel is not under another pixel previously rendered (z-buffer check). We can simply interpolate the <code class="language-plaintext highlighter-rouge">z value</code> for the pixel and compare it with what is stored in the z-buffer. Since everything is already projected on the screen, we take the z directly without any other transformation.</p>
  </li>
  <li>
    <p>We interpolate between the texture coordiantes for each vertex and take the corresponding diffuse value.</p>
  </li>
  <li>
    <p>We interpolate between the normals of each vertex to compute a pixel normal and <code class="language-plaintext highlighter-rouge">dot</code> it with the light direction to see how much light falls on that point. This is called <code class="language-plaintext highlighter-rouge">Phong Shading</code>, as opposed to <code class="language-plaintext highlighter-rouge">Gouraud Shading</code> where the light is calculated per vertex and then interpolated over the surphace.</p>
  </li>
</ul>

<h3 id="what-else">What Else?</h3>

<p>Building the camera matrix, which is similar to the <code class="language-plaintext highlighter-rouge">gluLookAt</code> from OpenGL. The two functions are interesting becasue they show two things:</p>
<ul>
  <li>How to make the inverse of an homogenous orthogonal matrix based on the transposed rotation.</li>
  <li>How to extract the axes of abject. Axes are oriented on columns.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">inverseOrthogonalMatrix</span><span class="p">(</span><span class="nx">mtx</span><span class="p">){</span>

    <span class="c1">// inverse is the transpose of the rotation part and `-` the translation</span>

    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">mtx</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">mtx</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">mtx</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">rotate</span> <span class="o">=</span> <span class="p">[</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">1</span>
    <span class="p">];</span>

    <span class="kd">let</span> <span class="nx">translate</span> <span class="o">=</span> <span class="p">[</span>
      <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nx">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nx">y</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nx">z</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">]</span>

    <span class="c1">// inverse = a) -translate followed by b) -rotate</span>
    <span class="k">return</span> <span class="nx">matrixMultiply</span><span class="p">(</span><span class="nx">rotate</span><span class="p">,</span> <span class="nx">translate</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">makeCameraTransform</span><span class="p">(</span><span class="nx">camPos</span><span class="p">,</span> <span class="nx">camUp</span><span class="p">,</span> <span class="nx">camLookAt</span><span class="p">){</span>

    <span class="c1">// camera looks towards -z, so here we need to inverse camCenter and camPos</span>
    <span class="kd">let</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">subtractVector</span><span class="p">(</span><span class="nx">camPos</span><span class="p">,</span> <span class="nx">camLookAt</span><span class="p">))</span>
    <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">camUp</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">crossProduct3</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">);</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="nx">crossProduct3</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">camWorld</span> <span class="o">=</span> <span class="p">[</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">camPos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">camPos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
      <span class="nx">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">camPos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
      <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="nx">cameraDir</span> <span class="o">=</span> <span class="p">[</span><span class="nx">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>

    <span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">inverseOrthogonalMatrix</span><span class="p">(</span><span class="nx">camWorld</span><span class="p">);</span>
    <span class="c1">//let identity = matrixMultiply(ret, camWorld); // debug</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>The depth buffer is initialized to the same size as the whole canvas, based on floats. For faster computations it can be initialized to integer numbers, but then care must be taken to defining the resolution in the viewport matrix.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">zBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float32Array</span><span class="p">(</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
</code></pre></div></div>

<p>Making the render buffer is done as follows:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">makeFullScreenCanvas</span><span class="p">(){</span>

    <span class="kd">const</span> <span class="nx">cvs</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myCanvas</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">;</span>
    <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="dl">"</span><span class="s2">2d</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">screenBuffer</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">createImageData</span><span class="p">(</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
    <span class="nx">zBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float32Array</span><span class="p">(</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

    <span class="nx">viewportTransform</span> <span class="o">=</span> <span class="nx">makeViewportTransform</span><span class="p">(</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">cvs</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>
    <span class="nx">projectionTransform</span> <span class="o">=</span> <span class="nx">makeProjectionTransform</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="nx">cameraTransform</span> <span class="o">=</span> <span class="nx">makeCameraTransform</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>

    <span class="nx">render</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And, before we go, let’s have a look once again at our model with all the transformations applied - this should be the output of running the code from github.</p>

<p><img src="https://alexandrugris.github.io/assets/tiny_5.png" alt="Head" /></p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
