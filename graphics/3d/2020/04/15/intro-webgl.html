<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>WebGL Fun</title>
  <meta name="description" content="A post about computer graphics, for the web mostly, with JavaScript, WebGL, ThreeJS and shaders. A little bit of maths also.">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/graphics/3d/2020/04/15/intro-webgl.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">WebGL Fun</h1>
    <p class="post-meta"><time datetime="2020-04-15T09:15:16+02:00" itemprop="datePublished">Apr 15, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>A post about computer graphics, for the web mostly, with JavaScript, WebGL, ThreeJS and shaders. A little bit of maths also.</p>

<h3 id="threejs-introduction">ThreeJS Introduction</h3>

<p><a href="https://threejs.org/">ThreeJS</a> is a minimalistic 3D game engine for the web, with a very simple to use and very nicely designed API. It comes in the form of a javascript library, accompanied by a set of util libraries, a scene editor running on the web and lots and lots of examples an tutorials.</p>

<p>By the end of this blog post we will build this:</p>

<p><img src="https://alexandrugris.github.io/assets/webgl_2.png" alt="Three JS Editor" /></p>

<p>By default, ThreeJS already has built in materials for most of the effects one might want to add to a scene. I addition to what is already built in, there are lots of samples and pre-made effects in the form of libraries on github. Therefore, for most work, it be used entirely from JavaScript. While the API is clean and short and performs as expected, a little bit of maths and graphics background will still be needed sooner or later in the project.</p>

<p><img src="https://alexandrugris.github.io/assets/webgl_1.png" alt="Three JS Editor" /></p>

<h3 id="initialization-and-the-first-scene">Initialization and The First Scene</h3>

<p>The simplest way to run ThreeJS is to cover the full browser window. It goes like this:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="c">&lt;!-- Run everything as a module --&gt;</span>
  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span><span class="nt">&gt;</span>

    <span class="k">import</span> <span class="p">{</span><span class="nx">main</span><span class="p">,</span> <span class="nx">resize</span><span class="p">}</span> <span class="k">from</span> <span class="s2">"./js/complex_scene.js"</span><span class="p">;</span>

    <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">main</span><span class="p">;</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">onresize</span> <span class="o">=</span> <span class="nx">resize</span><span class="p">;</span>

  <span class="nt">&lt;/script&gt;</span>

<span class="nt">&lt;/head&gt;</span>

<span class="nt">&lt;body&gt;</span>
  <span class="c">&lt;!-- Full screen, positioned top-left corner --&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"webgl-container"</span> <span class="na">style=</span><span class="s">"position: absolute; top: 0; left:0 ; margin: 0"</span><span class="nt">&gt;&lt;/div&gt;</span>

<span class="nt">&lt;/body&gt;</span>

<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>Then, in the JavaScript file:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// downloaded beforehand in the libs folder</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">THREE</span> <span class="k">from</span> <span class="s2">"./libs/three.module.js"</span> 

<span class="c1">// create new renderer</span>
<span class="kd">const</span> <span class="nx">renderer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">WebGLRenderer</span><span class="p">();</span>

<span class="c1">// util for variable frame rate</span>
<span class="kd">const</span> <span class="nx">clock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Clock</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

</code></pre></div></div>

<p>We are also going to make use of the following two functions, as vectors are kept by reference in the ThreeJS code and, in many cases, we need copies to do transforms only on resulting vector, not on the source.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">newVector</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">z</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">copyVector</span><span class="p">(</span><span class="nx">dest</span><span class="p">,</span> <span class="nx">src</span><span class="p">){</span>
  <span class="nx">dest</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">src</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
  <span class="nx">dest</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">src</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
  <span class="nx">dest</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">src</span><span class="p">.</span><span class="nx">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we can proceed further to initialization</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">resize</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">renderer</span><span class="p">.</span><span class="nx">setSize</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">camera</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">camera</span><span class="p">.</span><span class="nx">aspect</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span> <span class="o">/</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">;</span>
      <span class="nx">camera</span><span class="p">.</span><span class="nx">updateProjectionMatrix</span><span class="p">();</span> <span class="c1">// DON'T FORGET!</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// initialize the renderer</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">setSize</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"webgl-container"</span><span class="p">).</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">renderer</span><span class="p">.</span><span class="nx">domElement</span><span class="p">);</span>

  <span class="c1">// [LOAD SCENE HERE]</span>
  <span class="c1">// for the first demo will we create scene programatically,</span>
  <span class="c1">// for the second we load the scene as exported from the ThreeJS editor</span>

  <span class="c1">// if objects are loaded from the network, initScene should be async / awaited</span>
  <span class="nx">initScene</span><span class="p">();</span>
  <span class="nx">renderScene</span><span class="p">();</span>

<span class="p">}</span>

<span class="k">export</span> <span class="p">{</span> <span class="nx">main</span><span class="p">,</span> <span class="nx">resize</span> <span class="p">}</span>
</code></pre></div></div>

<p>We are also going to use the following global variables:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the scene object</span>
<span class="kd">const</span> <span class="nx">scene</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Scene</span><span class="p">();</span>

<span class="c1">// a light, must be added to the scene if we want to see something</span>
<span class="kd">const</span> <span class="nx">light</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">AmbientLight</span><span class="p">(</span><span class="mh">0xffffff</span><span class="p">);</span>

<span class="c1">// a camera</span>
<span class="kd">let</span> <span class="nx">camera</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div>

<p>Initialize them, add them to the scene:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">initScene</span><span class="p">(){</span>

  <span class="c1">// 1. create the renderer and add its element to the scene</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">setSize</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"webgl-container"</span><span class="p">).</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">renderer</span><span class="p">.</span><span class="nx">domElement</span><span class="p">);</span>

  <span class="c1">// 2. create the camera, position it in the world and add it to the scene</span>
  <span class="nx">camera</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">PerspectiveCamera</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="o">/</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="nx">camera</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">camera</span><span class="p">);</span>

  <span class="c1">// 3. add the light to the scene</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">light</span><span class="p">);</span>

  <span class="c1">// 4. Create an object. An object an item of the class THREE.Mesh()</span>
  <span class="c1">// It has two constituents: a geometry and a material</span>

  <span class="c1">// The geometry is created from the library of predefined geometries. </span>
  <span class="c1">// Check the docs for other prefedined geometries</span>

  <span class="c1">// The material is a single color (red) material, rendered in wireframe</span>
  <span class="c1">// wireframe property is set in the constructor.</span>
  <span class="c1">// ThreeJS predefines many materials for everyday use.  </span>
  <span class="kd">let</span> <span class="nx">box</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span>
    <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">BoxGeometry</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">(</span>
      <span class="p">{</span>
        <span class="na">color</span><span class="p">:</span> <span class="mh">0xff0000</span><span class="p">,</span>
        <span class="na">wireframe</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">})</span>
  <span class="p">);</span>

  <span class="c1">// 5. Give a name to my 3D object so we can find it in the scene later</span>
  <span class="nx">box</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">"my-box"</span><span class="p">;</span>

  <span class="c1">// 6. A super useful helper for debugging, the AxesHelper, shows the orientation of my 3D object.</span>
  <span class="c1">// This is added as a child to the box so it moves through the scene together with its parent.</span>
  <span class="nx">box</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">AxesHelper</span><span class="p">(</span><span class="mi">30</span><span class="p">));</span>

  <span class="c1">// 7. Add the box to the scene</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">box</span><span class="p">);</span>

  <span class="c1">// the next two objects will be detailed later</span>
  <span class="c1">// (a) how to create geometry programatically</span>
  <span class="c1">// (b) how to modify geometry programatically</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">createTriangleGeometry</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="kc">false</span><span class="p">));</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="k">new</span> <span class="nx">AnimatedPlaneGeometry</span><span class="p">());</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Beside the <code class="highlighter-rouge">THREE.MeshBasicMaterial</code> shown above, which is a flat renderer, not affected by lights, ThreeJS comes with a powerful material library. Some of the classes discussed below:</p>

<ul>
  <li><code class="highlighter-rouge">LineMaterial</code> - allows drawing lines</li>
  <li><code class="highlighter-rouge">LineDashMaterial</code> - allows drawing dashed lines</li>
  <li><code class="highlighter-rouge">MeshLambertMaterial</code> - basic per-vertex lighting, no specular</li>
  <li><code class="highlighter-rouge">MeshPhongMaterial</code> - per-pixel lighting, specular. Offers interesting properties for setting the diffuse texture, environment map, emissive, displacement map, bump map, light map, normal map, both object space and tangent space, etc.</li>
  <li><code class="highlighter-rouge">MeshToonMaterial</code> - toon shading</li>
  <li><code class="highlighter-rouge">MeshStandardMaterial</code> - physically-based rendering material</li>
  <li><code class="highlighter-rouge">SpriteMaterial</code> - rendering sprites</li>
  <li><code class="highlighter-rouge">DepthMaterial</code> - for rendering the depth buffer</li>
  <li><code class="highlighter-rouge">ShaderMaterial</code> - for custom shaders written in GLSL. We will use this material later on.</li>
</ul>

<p>The wide slection of materials available means that a lot can be done with just JavaScript, without touching any advanced rendering techniques or limiting custom rendering code to very special sections of your scene.</p>

<p>Redering the scene is super easy as well:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">render</span><span class="p">(){</span>

  <span class="c1">// 1. optinally call an update method</span>
  <span class="c1">// to update your scene based on the advance of time</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">clock</span><span class="p">.</span><span class="nx">getDelta</span><span class="p">())</span>

  <span class="c1">// 2. render the scene</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">scene</span><span class="p">,</span> <span class="nx">camera</span><span class="p">);</span>
  <span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">render</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="fun-with-vertices">Fun With Vertices</h3>

<p>We mentioned two more objects in the scene initialization code above:</p>

<ul>
  <li>Generating geometry</li>
  <li>Updating geometry</li>
</ul>

<p>Here it is how it goes:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createTriangleGeometry</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">singleColor</span> <span class="o">=</span> <span class="kc">false</span><span class="p">){</span>

  <span class="c1">// 1. Create a geometry object and push some vertices to it.</span>
  <span class="c1">// In this case we create a triangle</span>
  <span class="kd">let</span> <span class="nx">geom</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Geometry</span><span class="p">();</span>
  <span class="nx">geom</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="o">-</span><span class="nx">size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="nx">geom</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="nx">size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="nx">geom</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">((</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">*</span> <span class="nx">size</span> <span class="o">*</span> <span class="nx">size</span> <span class="p">)),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// 2. Set the indexes for each triangle constituting the geometry</span>
  <span class="c1">// In our case, we have a single face since we draw a single triangle</span>
  <span class="c1">// ThreeJS uses indexed geometries.</span>
  <span class="nx">geom</span><span class="p">.</span><span class="nx">faces</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Face3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

  <span class="kd">let</span> <span class="nx">mat</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

  <span class="c1">// 3. Set the material properties</span>
  <span class="c1">// in the `else` case we setup vertex colors which will be sent to the shaders as</span>
  <span class="c1">// vertex color parameters.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">singleColor</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mat</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">({</span><span class="na">color</span><span class="p">:</span> <span class="mh">0x00ff00</span><span class="p">});</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
     <span class="nx">mat</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">({</span>
      <span class="na">side</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">DoubleSide</span><span class="p">,</span>
      <span class="na">vertexColors</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">VertexColors</span>
    <span class="p">})</span>

    <span class="nx">geom</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">vertexColors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Color</span><span class="p">(</span><span class="mh">0xff0000</span><span class="p">);</span>
    <span class="nx">geom</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">vertexColors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Color</span><span class="p">(</span><span class="mh">0x00ff00</span><span class="p">);</span>
    <span class="nx">geom</span><span class="p">.</span><span class="nx">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">vertexColors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Color</span><span class="p">(</span><span class="mh">0x0000ff</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="c1">// 4. Return the mesh that can be added to the Scene</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">(</span><span class="nx">geom</span><span class="p">,</span> <span class="nx">mat</span><span class="p">);</span>

  <span class="c1">// 5. Check out ExtrudeGeometry and ShapeGeometry and GeometryUtils </span>
  <span class="c1">// for different means and utilities for generating geometry in code</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And updating geometry on the fly:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">AnimatedPlaneGeometry</span> <span class="kd">extends</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Mesh</span><span class="p">{</span>

  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. initialize this geomerty as a plane</span>
    <span class="k">super</span><span class="p">(</span><span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">PlaneGeometry</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> 
          <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">MeshBasicMaterial</span><span class="p">({</span><span class="na">wireframe</span><span class="p">:</span> <span class="kc">true</span><span class="p">}))</span> <span class="p">;</span>
    
    <span class="c1">// 2. give it a name so it can be accessed from the scene</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">"my-wave"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">){</span>

    <span class="c1">// 3. update the geometry, this is a sinosoidal wave</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">z</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">vertices</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">x</span> <span class="o">+</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 4.: must call the following to update the geometry. </span>
    <span class="c1">// otherwise the buffers will not be updated</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">geometry</span><span class="p">.</span><span class="nx">verticesNeedUpdate</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If all went well, with an update function like the following,</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">box</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s2">"my-box"</span><span class="p">);</span>
  <span class="nx">box</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nx">y</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>

  <span class="kd">let</span> <span class="nx">wave</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s2">"my-wave"</span><span class="p">);</span>
  <span class="nx">wave</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Something like the following scene should appear in the browser. The full code is in my github account, in the WebGL project.</p>

<p><img src="https://alexandrugris.github.io/assets/webgl_3.png" alt="JS Scene" /></p>

<p>The scene contains:</p>
<ul>
  <li>The red wireframe cube rotating (<code class="highlighter-rouge">my-box</code>) with the <code class="highlighter-rouge">AxesHelper</code> added and rotating with its parent.</li>
  <li>The waving plane, updated geometry (<code class="highlighter-rouge">my-wave</code>).</li>
  <li>The colorful triangle created on the fly.</li>
</ul>

<h3 id="shaders-and-rendering-of-the-earth">Shaders and Rendering Of The Earth</h3>

<p>Why the Earth? Because textures can be found free online, because rendering it requires some specific techniques, like skyboxes, normal mapping, lighting, atmosphere rendering and because the result is guaranteed to be beautiful.</p>

<p>A very good rendering of the Earth can be obtained by using materials already provided by the engine or by the community. However, since this was a pet project, we are doing many things from scratch. Also, being a pet project written among other things, the code is not production ready. I have not tested it on other computer except for my laptop which is quite powerful. Also, I have not optimized the code. It’s just the first thing that worked.</p>

<h3 id="loading-the-scene">Loading the Scene</h3>

<p>Unlike the previous example where we built the scene manually, here I created it in the ThreeJS editor and then exported it. The loading code goes like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">//1. initialize the renderer</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">setSize</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"webgl-container"</span><span class="p">).</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">renderer</span><span class="p">.</span><span class="nx">domElement</span><span class="p">);</span>

  <span class="c1">//2. load the scene from editor exported objects</span>
  <span class="nx">scene</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">loadObject</span><span class="p">(</span><span class="s2">"./assets/earth_and_water.json"</span><span class="p">);</span>
  <span class="nx">camera</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">loadObject</span><span class="p">(</span><span class="s2">"./assets/camera.json"</span><span class="p">);</span>

  <span class="c1">//3. fix the camera, the camera has also been loaded from JSON, but its parameters</span>
  <span class="c1">// neeed to be adjusted to our viewport</span>
  <span class="nx">camera</span><span class="p">.</span><span class="nx">aspect</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="o">/</span><span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span><span class="p">;</span>
  <span class="nx">camera</span><span class="p">.</span><span class="nx">updateProjectionMatrix</span><span class="p">();</span>
  <span class="nx">camera</span><span class="p">.</span><span class="nx">updateMatrixWorld</span><span class="p">();</span>

  <span class="c1">//4. load the FlyControls library (premade) so we can move through the scene</span>
  <span class="nx">cameraControls</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FlyControls</span><span class="p">(</span><span class="nx">camera</span><span class="p">,</span> <span class="nx">renderer</span><span class="p">.</span><span class="nx">domElement</span><span class="p">);</span>
  <span class="nx">cameraControls</span><span class="p">.</span><span class="nx">dragToLook</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">cameraControls</span><span class="p">.</span><span class="nx">movementSpeed</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span> <span class="c1">// scene-units per second</span>
  <span class="nx">cameraControls</span><span class="p">.</span><span class="nx">rollSpeed</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c1">// radians per second</span>

  <span class="c1">//5. the skybox requires separate treatment, will be coved later in the post</span>
  <span class="c1">// her we remove it from the scene </span>
  <span class="nx">skybox</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s1">'SkyBox'</span><span class="p">);</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">skybox</span><span class="p">);</span>

  <span class="c1">//6. we are also fixing the atmosphere and make it a child of the earth so the move together</span>
  <span class="nx">earth</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s2">"Earth"</span><span class="p">);</span>
  <span class="nx">atmosphere</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s2">"Atmosphere"</span><span class="p">);</span>
  <span class="nx">scene</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">atmosphere</span><span class="p">);</span>
  <span class="nx">earth</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">atmosphere</span><span class="p">);</span>

  <span class="c1">//7. setup the shaders</span>
  <span class="nx">fixMaterials</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="c1">// 8. since we have a skybox rendered as a separate step</span>
    <span class="c1">// we don't want to renderer to erase the scene for us between rendering</span>
    <span class="c1">// also part of the rendering of the skybox</span>
    <span class="nx">renderer</span><span class="p">.</span><span class="nx">autoClear</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nx">scene</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="c1">// 9. start the renderign loop</span>
    <span class="nx">render</span><span class="p">()</span>
<span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For loading the scene and the textures we are going to use two functions:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">loadObject</span><span class="p">(</span><span class="nx">json</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">objLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">ObjectLoader</span><span class="p">();</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="p">(</span><span class="nx">accept</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">objLoader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="nx">json</span><span class="p">,</span> <span class="nx">accept</span><span class="p">,</span> <span class="kc">null</span> <span class="p">,</span><span class="nx">reject</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="nx">texture</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">imgLoader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">TextureLoader</span><span class="p">();</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">imgLoader</span><span class="p">.</span><span class="nx">load</span><span class="p">(</span><span class="nx">texture</span><span class="p">,</span> <span class="p">(</span><span class="nx">tex</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="c1">// here we are intercepting the texture loader</span>
    <span class="c1">// we want the textures to be as beautifully rendered as possible at the cost of performance</span>
    <span class="c1">// therefore, we use the highest anisotropy level the renderer provides</span>
    <span class="c1">// for my device, it is 16</span>
    <span class="c1">// this makes the textures look sharp when seen from the side</span>
    <span class="c1">// https://en.wikipedia.org/wiki/Texture_filtering#Anisotropic_filtering</span>
    <span class="nx">tex</span><span class="p">.</span><span class="nx">anisotropy</span> <span class="o">=</span> <span class="nx">renderer</span><span class="p">.</span><span class="nx">capabilities</span><span class="p">.</span><span class="nx">getMaxAnisotropy</span><span class="p">();</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">tex</span><span class="p">);</span>
    <span class="p">},</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">reject</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Setting up a shader is performed in the <code class="highlighter-rouge">fixMaterials</code> function. Its basic structure as as follows:</p>

<ol>
  <li>Define the set of uniforms and bind them to JS variables. Uniforms are the variables that are set in code and submitted on each rendering pass to the shading programs.</li>
  <li>Create a <code class="highlighter-rouge">ShaderMaterial</code></li>
  <li>Set the uniforms and then load the vertex shader and the pixel shaders. In our case, we store these in our DOM tree, in the html file.</li>
</ol>

<p>Let’s perform these steps to render the sky dome. In our case it’s a sphere, not box.</p>

<h3 id="skydome-and-light">SkyDome And Light</h3>

<ol>
  <li>Setting up the uniforms:</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">fixMaterials</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// first is the SkyBox</span>
  <span class="nx">skyBoxUniforms</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">diffuseTexture</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="s2">"./assets/sky/sky_at_night.jpg"</span><span class="p">)</span>
    <span class="p">},</span>
  <span class="p">}</span>

  <span class="p">[...</span> <span class="nx">more</span> <span class="nx">to</span> <span class="nx">come</span> <span class="nx">here</span> <span class="p">...]</span>
</code></pre></div></div>

<ol>
  <li>Create the <code class="highlighter-rouge">ShaderMaterial</code>:</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nx">skybox</span><span class="p">.</span><span class="nx">material</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">ShaderMaterial</span><span class="p">({</span>

    <span class="c1">// a) set the uniforms</span>
    <span class="na">uniforms</span><span class="p">:</span> <span class="nx">skyBoxUniforms</span><span class="p">,</span>

    <span class="c1">// b) load the vertex and pixel shader from the HTML DOM</span>
    <span class="na">vertexShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"skyBoxVertexShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>
    <span class="na">fragmentShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"skyBoxFragmentShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>

    <span class="c1">// c) set other parameters</span>
    <span class="c1">// In our case, always show the skybox behind all other objects</span>
    <span class="na">depthTest</span> <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">depthWrite</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>

    <span class="c1">// d) we are always inside the box</span>
    <span class="na">side</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">BackSide</span><span class="p">,</span>

  <span class="p">});</span>
</code></pre></div></div>

<p>Rendering the skybox is a bit trick as the following are done:</p>

<ul>
  <li>The skybox is always as at the same distance from the camera. We don’t get closer to it, we don’t get further from it. It moves with the camera.</li>
  <li>The skybox is behind any object in the scene, it cannot intersect any object. Thus we don’t update the the Z-buffer and we don’t read from it. We render the skybox as a separate step and we don’t erase the background between rendering the skybox and rendering the rest of the scene.</li>
</ul>

<p>Here’s how the rendering loop looks like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">render</span><span class="p">(){</span>

<span class="c1">// 1. update the scene, geometries, etc</span>
  <span class="nx">update</span><span class="p">(</span><span class="nx">clock</span><span class="p">.</span><span class="nx">getDelta</span><span class="p">())</span>

<span class="c1">// 2. clear the background</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>

<span class="c1">// 3. render the skybox</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">skybox</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">){</span>
    <span class="nx">renderer</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">skybox</span><span class="p">,</span> <span class="nx">camera</span><span class="p">);</span>
  <span class="p">}</span>

<span class="c1">// 4. without clearing the background, render the rest of the scene</span>
  <span class="nx">renderer</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">scene</span><span class="p">,</span> <span class="nx">camera</span><span class="p">);</span>
  <span class="nx">requestAnimationFrame</span><span class="p">(</span><span class="nx">render</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The shaders for the skybox are super straight forward, as we don’t apply any lighting to it.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"x-shader/x-vertex"</span> <span class="na">id=</span><span class="s">"skyBoxVertexShader"</span><span class="nt">&gt;</span>

    <span class="nx">uniform</span> <span class="nx">vec3</span>          <span class="nx">lightDirection</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">vec3</span>          <span class="nx">cameraDirection</span><span class="p">;</span>

    <span class="nx">varying</span> <span class="nx">vec2</span>          <span class="nx">vUv</span><span class="p">;</span> <span class="c1">// pass the uv coordinates of each vertex to the frag shader</span>
    <span class="nx">varying</span> <span class="kr">float</span>         <span class="nx">lightIntensity</span><span class="p">;</span>

    <span class="k">void</span> <span class="nx">main</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="nx">vUv</span> <span class="o">=</span> <span class="nx">uv</span><span class="p">;</span>
      <span class="nx">gl_Position</span> <span class="o">=</span> <span class="nx">projectionMatrix</span> <span class="o">*</span> <span class="nx">modelViewMatrix</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="c1">// artistic effect: dim when looking at the light source</span>
      <span class="c1">// no special reason for the effect, just feel nicer</span>
      <span class="c1">// it should be computed outside the shader</span>
      <span class="kr">float</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">normalize</span><span class="p">(</span><span class="nx">cameraDirection</span><span class="p">),</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">lightDirection</span><span class="p">));</span>
      <span class="nx">lightIntensity</span> <span class="o">=</span> <span class="nx">clamp</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span> <span class="nx">i</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>

  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"x-shader/x-fragment"</span> <span class="na">id=</span><span class="s">"skyBoxFragmentShader"</span><span class="nt">&gt;</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">diffuseTexture</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec2</span> <span class="nx">vUv</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="kr">float</span> <span class="nx">lightIntensity</span><span class="p">;</span>

    <span class="k">void</span> <span class="nx">main</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="nx">gl_FragColor</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">diffuseTexture</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">)</span> <span class="o">*</span> <span class="nx">lightIntensity</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Now, the trickery has not yet finished. We have a sun that needs to stick to the skybox when the skybox rotates and moves through the scene, remember it is bound to the camera, and we want to make sure the light direction is preserved and it accurately comes from the sun. So we do these updates in the update method.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">){</span>

  <span class="c1">// 1. Allow the camera to move</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">cameraControls</span><span class="p">){</span>
    <span class="nx">cameraControls</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 2. ensure the sun and the light have the same direction and they stick to the skybox</span>
  <span class="kd">let</span> <span class="nx">sunLight</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s1">'sun_light'</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">sunSprite</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">getObjectByName</span><span class="p">(</span><span class="s1">'sun_sprite'</span><span class="p">);</span>

  <span class="kd">let</span> <span class="nx">lightPos</span> <span class="o">=</span> <span class="nx">sunLight</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>
  <span class="kd">let</span> <span class="nx">lightPosU</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">(</span><span class="nx">newVector</span><span class="p">(</span><span class="nx">lightPos</span><span class="p">));</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">skybox</span><span class="p">)</span> <span class="p">{</span>

      <span class="nx">copyVector</span><span class="p">(</span><span class="nx">skybox</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="nx">camera</span><span class="p">.</span><span class="nx">position</span><span class="p">);</span>
      <span class="nx">skybox</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nx">x</span> <span class="o">+=</span> <span class="mf">0.005</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>
      <span class="nx">skybox</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nx">y</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>

      <span class="kd">let</span> <span class="nx">cameraDir</span> <span class="o">=</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setFromMatrixColumn</span><span class="p">(</span><span class="nx">camera</span><span class="p">.</span><span class="nx">matrixWorld</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="nx">normalize</span><span class="p">();</span>

      <span class="nx">skyBoxUniforms</span><span class="p">.</span><span class="nx">lightDirection</span> <span class="o">=</span> <span class="nx">lightPosU</span><span class="p">;</span>
      <span class="nx">skyBoxUniforms</span><span class="p">.</span><span class="nx">cameraDirection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">(</span><span class="nx">cameraDir</span><span class="p">);</span>


      <span class="nx">skybox</span><span class="p">.</span><span class="nx">updateMatrixWorld</span><span class="p">();</span>

      <span class="c1">// keep the sun in the same place in the sky</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalPositionSkyboxSpace</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">){</span>
        <span class="c1">// the sun sprite</span>
        <span class="kd">let</span> <span class="nx">invWorld</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Matrix4</span><span class="p">();</span>

        <span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalPositionSkyboxSpace</span> <span class="o">=</span> <span class="nx">newVector</span><span class="p">(</span><span class="nx">sunSprite</span><span class="p">.</span><span class="nx">position</span><span class="p">);</span>
        <span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalPositionSkyboxSpace</span><span class="p">.</span><span class="nx">applyMatrix4</span><span class="p">(</span><span class="nx">invWorld</span><span class="p">.</span><span class="nx">getInverse</span><span class="p">(</span><span class="nx">skybox</span><span class="p">.</span><span class="nx">matrixWorld</span><span class="p">));</span>
        <span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalSkyboxPosition</span> <span class="o">=</span> <span class="nx">newVector</span><span class="p">(</span><span class="nx">skybox</span><span class="p">.</span><span class="nx">position</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// make sure the light comes from the sun and not some random point</span>
      <span class="kd">let</span> <span class="nx">newPos</span> <span class="o">=</span> <span class="nx">newVector</span><span class="p">(</span><span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalPositionSkyboxSpace</span><span class="p">);</span>
      <span class="nx">newPos</span><span class="p">.</span><span class="nx">applyMatrix4</span><span class="p">(</span><span class="nx">skybox</span><span class="p">.</span><span class="nx">matrixWorld</span><span class="p">);</span>
      <span class="nx">copyVector</span><span class="p">(</span><span class="nx">sunSprite</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="nx">newPos</span><span class="p">);</span>
      <span class="nx">sunSprite</span><span class="p">.</span><span class="nx">updateMatrixWorld</span><span class="p">();</span>

      <span class="nx">lightPos</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">();</span>
      <span class="kd">let</span> <span class="nx">skyboxMovement</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Vector3</span><span class="p">();</span>
      <span class="nx">skyboxMovement</span><span class="p">.</span><span class="nx">subVectors</span><span class="p">(</span><span class="nx">skybox</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="nx">sunSprite</span><span class="p">.</span><span class="nx">originalSkyboxPosition</span><span class="p">);</span>
      <span class="nx">lightPos</span><span class="p">.</span><span class="nx">subVectors</span><span class="p">(</span><span class="nx">sunSprite</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="nx">skyboxMovement</span><span class="p">);</span>
      <span class="nx">copyVector</span><span class="p">(</span><span class="nx">sunLight</span><span class="p">.</span><span class="nx">position</span><span class="p">,</span> <span class="nx">lightPos</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<h3 id="rendering-the-earth">Rendering the Earth</h3>

<p>Now, rendering of the Earth and its atmosphere can vastly be improved, especially perfomance-wise. But I am running out of vacation time and I really want to finish this project today so I stop at the current implementation. Some quick wins:</p>

<ul>
  <li>Make lighting done in tangent space. It will reduce some matrix multiplications in the pixel shader.</li>
  <li>Make the atmosphere rendering per-pixel. Now the atmosphere thickness is computed per vertex and this gives some ugly artefacts.</li>
  <li>Tune the clouds and their shadows. While the shadow moves correctly with the camera, when they are brightly lit or when they are not fully lit there are some visual artefacts.</li>
</ul>

<p>But let’s start with the Earth.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. setup the uniforms, load the textures</span>
<span class="nx">earthUniforms</span> <span class="o">=</span> <span class="p">{</span>

    <span class="na">diffuseTexture</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="s2">"./assets/earth/earth_diffuse.jpg"</span><span class="p">)</span>
    <span class="p">},</span>

    <span class="na">diffuseNight</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="s2">"./assets/earth/earth_diffuse_night.jpg"</span><span class="p">)</span>
    <span class="p">},</span>

    <span class="na">normalMap</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span><span class="s2">"./assets/earth/earth_normal_map.png"</span><span class="p">)</span>
    <span class="p">},</span>

    <span class="na">specularMap</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span> <span class="s2">"./assets/earth/earth_specular_map.png"</span><span class="p">)</span>
    <span class="p">},</span>

    <span class="na">cloudsMap</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="s2">"t"</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">await</span> <span class="nx">loadTexture</span><span class="p">(</span> <span class="s2">"./assets/earth/clouds1.jpg"</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="p">}</span>

<span class="c1">// 2. Cheat a bit and use a library function to compute the tangets</span>
<span class="c1">// We will be using tangent-space normal mapping. The function was too easy to grab </span>
<span class="c1">// not to use it.</span>

<span class="nx">BufferGeometryUtils</span><span class="p">.</span><span class="nx">computeTangents</span><span class="p">(</span><span class="nx">earth</span><span class="p">.</span><span class="nx">geometry</span><span class="p">);</span>

<span class="c1">// 3. setup the vertex shader and the fragment shader</span>
<span class="nx">earth</span><span class="p">.</span><span class="nx">material</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">ShaderMaterial</span><span class="p">({</span>

    <span class="na">uniforms</span><span class="p">:</span> <span class="nx">earthUniforms</span><span class="p">,</span>

    <span class="na">vertexShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"earthVertexShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>
    <span class="na">fragmentShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"earthFragmentShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>

    <span class="na">side</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">FrontSide</span>

  <span class="p">});</span>
</code></pre></div></div>

<p>In the update function, we also update the position and we bind the updated light position to the shader:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="nx">dt</span><span class="p">){</span>

  <span class="p">[....]</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">earth</span><span class="p">){</span>
    <span class="nx">earthUniforms</span><span class="p">.</span><span class="nx">lightDirection</span> <span class="o">=</span> <span class="nx">lightPosU</span><span class="p">;</span>
    <span class="nx">earth</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nx">x</span> <span class="o">-=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span> <span class="c1">// some rotation</span>
    <span class="nx">earth</span><span class="p">.</span><span class="nx">rotation</span><span class="p">.</span><span class="nx">y</span> <span class="o">+=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="nx">dt</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the shaders, with comments:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">"x-shader/x-vertex"</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"earthVertexShader"</span><span class="o">&gt;</span>

    <span class="nx">uniform</span> <span class="nx">vec3</span> <span class="nx">lightDirection</span><span class="p">;</span>

    <span class="c1">// send to fragment shader</span>
    <span class="c1">// all in eye space</span>
    <span class="nx">varying</span> <span class="nx">vec2</span> <span class="nx">vUv</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vEyeDirectionEyeSpace</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vLightDirection</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">mat3</span> <span class="nx">tbn</span><span class="p">;</span>

    <span class="c1">// the tangent, sent per-vertex </span>
    <span class="nx">attribute</span> <span class="nx">vec4</span> <span class="nx">tangent</span><span class="p">;</span>

    <span class="k">void</span> <span class="nx">main</span><span class="p">(){</span>

      <span class="c1">// 1. copy the texture coordinates</span>
      <span class="nx">vUv</span> <span class="o">=</span> <span class="nx">uv</span><span class="p">;</span>

      <span class="c1">// 2. update the position</span>
      <span class="nx">gl_Position</span> <span class="o">=</span> <span class="nx">projectionMatrix</span> <span class="o">*</span> <span class="nx">modelViewMatrix</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="c1">// 3. compute the light direction from world to eye;</span>
      <span class="c1">// should be computed outside of shader for performance</span>
      <span class="nx">vLightDirection</span> <span class="o">=</span> <span class="nx">mat3</span><span class="p">(</span><span class="nx">viewMatrix</span><span class="p">)</span> <span class="o">*</span> <span class="nx">lightDirection</span><span class="p">;</span> 

      <span class="c1">// 4. compute the direction to the eye</span>
      <span class="nx">vEyeDirectionEyeSpace</span> <span class="o">=</span> <span class="nx">mat3</span><span class="p">(</span><span class="nx">viewMatrix</span><span class="p">)</span> <span class="o">*</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">position</span> <span class="o">-</span> <span class="nx">cameraPosition</span><span class="p">).</span><span class="nx">xyz</span><span class="p">;</span>

      <span class="c1">// 5. prepare the tangent-bitangent-normal matrix for normal mapping</span>
      <span class="nx">vec3</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">tangent</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
      <span class="nx">vec3</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">normal</span><span class="p">.</span><span class="nx">xyz</span><span class="p">);</span>
      <span class="nx">vec3</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">cross</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">n</span><span class="p">));</span>

      <span class="c1">// everything in eye space</span>
      <span class="nx">t</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span> <span class="o">*</span> <span class="nx">t</span><span class="p">);</span>
      <span class="nx">b</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span> <span class="o">*</span> <span class="nx">b</span><span class="p">);</span>
      <span class="nx">n</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span> <span class="o">*</span> <span class="nx">n</span><span class="p">);</span>

      <span class="nx">tbn</span> <span class="o">=</span> <span class="nx">mat3</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>
    <span class="p">}</span>

<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span>
<span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">"x-shader/x-fragment"</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"earthFragmentShader"</span><span class="o">&gt;</span>

    <span class="c1">// all my textures</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">diffuseTexture</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">diffuseNight</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">specularMap</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">cloudsMap</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">sampler2D</span> <span class="nx">normalMap</span><span class="p">;</span>

    <span class="c1">// inputs, interpolated per vertex</span>
    <span class="nx">varying</span> <span class="nx">vec2</span> <span class="nx">vUv</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vEyeDirectionEyeSpace</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vLightDirection</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">mat3</span> <span class="nx">tbn</span><span class="p">;</span>

    <span class="k">void</span> <span class="nx">main</span><span class="p">(){</span>


      <span class="nx">vec3</span> <span class="nx">lightDir</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">vLightDirection</span><span class="p">);</span>

      <span class="c1">// 1. compute the normal based on the texture and bring it to eye space</span>
      <span class="nx">vec3</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">normalMap</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">).</span><span class="nx">xyz</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">;</span>
      <span class="nx">vec3</span> <span class="nx">normal</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">tbn</span> <span class="o">*</span> <span class="nx">n</span><span class="p">);</span>

      <span class="c1">// 2. directional light</span>
      <span class="kr">float</span> <span class="nx">lightIntensity</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">normal</span><span class="p">,</span> <span class="nx">lightDir</span><span class="p">);</span>

      <span class="c1">// 3. use the surface normal, stored in tbn[2], as a selector for the day-night texture</span>
      <span class="c1">// we don't do lighting per se, we use a blend of day/night textures for it</span>
      <span class="kr">float</span> <span class="nx">selectImage</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">tbn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">lightDir</span><span class="p">);</span>
      <span class="nx">gl_FragColor</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">diffuseTexture</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">)</span> <span class="o">*</span> <span class="nx">selectImage</span> <span class="o">+</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">diffuseNight</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="nx">selectImage</span><span class="p">);</span>

      <span class="c1">// 4. we light the pixels a bit, true, but we only use the remainer from the intensity-select,</span>
      <span class="c1">// so we don't overlight </span>
      <span class="nx">gl_FragColor</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">10.0</span><span class="o">*</span><span class="p">(</span><span class="nx">lightIntensity</span> <span class="o">-</span> <span class="nx">selectImage</span><span class="p">));</span>

      <span class="c1">// 5.  specular</span>
      <span class="nx">vec3</span> <span class="nx">reflection</span> <span class="o">=</span> <span class="nx">reflect</span><span class="p">(</span><span class="nx">lightDir</span><span class="p">,</span> <span class="nx">normal</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">specPower</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">specularMap</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">).</span><span class="nx">r</span><span class="p">;</span>

      <span class="kr">float</span> <span class="nx">spec</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span>
      <span class="kr">float</span> <span class="nx">gloss</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">specularMap</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">).</span><span class="nx">a</span><span class="p">;</span>

      <span class="kr">float</span> <span class="nx">specular</span> <span class="o">=</span>  <span class="nx">pow</span><span class="p">(</span><span class="nx">clamp</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">reflection</span><span class="p">,</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">vEyeDirectionEyeSpace</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="nx">spec</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gloss</span><span class="p">;</span>
      <span class="nx">gl_FragColor</span> <span class="o">=</span> <span class="nx">gl_FragColor</span> <span class="o">+</span> <span class="nx">specular</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="mf">0.26</span><span class="p">,</span> <span class="mf">0.96</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

      <span class="c1">// 6. cloud colors</span>
      <span class="nx">vec4</span> <span class="nx">cloudsColor</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">cloudsMap</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">)</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

      <span class="c1">// 7. fake cloud shadow based on how we are looking at the cloud, to give some impression of depth</span>
      <span class="nx">vec4</span> <span class="nx">cloudsShadow</span> <span class="o">=</span> <span class="nx">texture2D</span><span class="p">(</span><span class="nx">cloudsMap</span><span class="p">,</span> <span class="nx">vec2</span><span class="p">(</span><span class="nx">vUv</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">normal</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="mf">0.005</span><span class="p">,</span> <span class="nx">vUv</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">normal</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="mf">0.005</span><span class="p">));</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">cloudsColor</span><span class="p">.</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="o">&amp;&amp;</span> <span class="nx">cloudsShadow</span><span class="p">.</span><span class="nx">r</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">){</span>
        <span class="nx">gl_FragColor</span> <span class="o">*=</span> <span class="mf">0.75</span><span class="p">;</span>
        <span class="nx">cloudsShadow</span> <span class="o">=</span> <span class="nx">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="nx">gl_FragColor</span> <span class="o">=</span> <span class="nx">gl_FragColor</span> <span class="o">*</span> <span class="p">(</span><span class="nx">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="nx">cloudsColor</span><span class="p">)</span> <span class="o">+</span> <span class="nx">cloudsColor</span> <span class="o">*</span> <span class="p">(</span><span class="nx">lightIntensity</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">);</span>

    <span class="p">}</span>

<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p>And last, but not least, the atmosphere. This is the most beautiful part of the model imho.</p>

<p>The first thing to note is that the atmosphere is using alpha blending. Nothing fancy, but without the earth beneath it won’t be visible. The atmosphere itself is a sphere with no texture, rendered on top of the earth and rotating together with it. Here is the shader config:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="nx">atmosphereUniforms</span> <span class="o">=</span> <span class="p">{</span>

    <span class="na">earthCenter</span><span class="p">:</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">(</span><span class="nx">earth</span><span class="p">.</span><span class="nx">position</span><span class="p">),</span>
    <span class="na">earthRadius</span><span class="p">:</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">(</span><span class="mf">10.0</span><span class="p">),</span>
    <span class="na">atmosphereRadius</span><span class="p">:</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">Uniform</span><span class="p">(</span><span class="mf">10.4</span><span class="p">),</span>

  <span class="p">}</span>

  <span class="nx">atmosphere</span><span class="p">.</span><span class="nx">material</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">ShaderMaterial</span><span class="p">({</span>
    <span class="na">uniforms</span><span class="p">:</span> <span class="nx">atmosphereUniforms</span><span class="p">,</span>

    <span class="na">vertexShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"atmosphereVertexShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>
    <span class="na">fragmentShader</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"atmosphereFragmentShader"</span><span class="p">).</span><span class="nx">innerText</span><span class="p">,</span>

    <span class="na">blending</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">CustomBlending</span><span class="p">,</span>
    <span class="na">blendEquation</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">AddEquation</span><span class="p">,</span>
    <span class="na">blendSrc</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">SrcAlphaFactor</span><span class="p">,</span>
    <span class="na">blendDst</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">OneMinusSrcAlphaFactor</span><span class="p">,</span>
    <span class="na">side</span><span class="p">:</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">FrontSide</span><span class="p">,</span>

    <span class="na">transparent</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="p">});</span>
</code></pre></div></div>

<p>And the shaders:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"x-shader/x-vertex"</span> <span class="na">id=</span><span class="s">"atmosphereVertexShader"</span><span class="nt">&gt;</span>

    <span class="nx">uniform</span> <span class="nx">vec3</span> <span class="nx">earthCenter</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="kr">float</span> <span class="nx">earthRadius</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="kr">float</span> <span class="nx">atmosphereRadius</span><span class="p">;</span>
    <span class="nx">uniform</span> <span class="nx">vec3</span> <span class="nx">lightDirection</span><span class="p">;</span>

    <span class="nx">varying</span> <span class="kr">float</span> <span class="nx">atmosphereThickness</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vLightDirection</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vNormalEyeSpace</span><span class="p">;</span>


    <span class="k">void</span> <span class="nx">main</span><span class="p">(){</span>

      <span class="c1">// 1. compute the position</span>
      <span class="nx">gl_Position</span> <span class="o">=</span> <span class="nx">projectionMatrix</span> <span class="o">*</span> <span class="nx">modelViewMatrix</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>


      <span class="c1">// 2. compute the thinckness of the atmosphere</span>
      <span class="c1">// for this, we intersect the vector (eye - current vertex) with the atmosphere and the earth</span>
      <span class="c1">// and we compute how long this line is. In pixel shader we compute the light scattering based on this measure</span>
      <span class="c1">// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection</span>

      <span class="nx">vec3</span> <span class="nx">positionW</span> <span class="o">=</span> <span class="p">(</span><span class="nx">modelMatrix</span> <span class="o">*</span> <span class="nx">vec4</span><span class="p">(</span><span class="nx">position</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)).</span><span class="nx">xyz</span><span class="p">;</span>

      <span class="nx">vec3</span> <span class="nx">vCameraEarth</span> <span class="o">=</span> <span class="nx">cameraPosition</span><span class="p">.</span><span class="nx">xyz</span> <span class="o">-</span> <span class="nx">earthCenter</span><span class="p">;</span>
      <span class="nx">vec3</span> <span class="nx">vCameraVertex</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">cameraPosition</span><span class="p">.</span><span class="nx">xyz</span> <span class="o">-</span> <span class="nx">positionW</span><span class="p">);</span>

      <span class="kr">float</span> <span class="nx">tca</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">vCameraEarth</span><span class="p">,</span>  <span class="nx">vCameraVertex</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">tca</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">){</span>
        <span class="c1">// not intesect, looking in opposite direction</span>
        <span class="nx">atmosphereThickness</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kr">float</span> <span class="nx">dsq</span> <span class="o">=</span> <span class="nx">dot</span><span class="p">(</span><span class="nx">vCameraEarth</span><span class="p">,</span> <span class="nx">vCameraEarth</span><span class="p">)</span> <span class="o">-</span> <span class="nx">tca</span> <span class="o">*</span> <span class="nx">tca</span><span class="p">;</span>
      <span class="kr">float</span> <span class="nx">thc_sq_atmosphere</span> <span class="o">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">atmosphereRadius</span> <span class="o">*</span> <span class="nx">atmosphereRadius</span> <span class="o">-</span> <span class="nx">dsq</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">thc_sq_earth</span> <span class="o">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">earthRadius</span> <span class="o">*</span> <span class="nx">earthRadius</span> <span class="o">-</span> <span class="nx">dsq</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

      <span class="kr">float</span> <span class="nx">thc_atmosphere</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">sqrt</span><span class="p">(</span><span class="nx">thc_sq_atmosphere</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">thc_earth</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">sqrt</span><span class="p">(</span><span class="nx">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="nx">thc_sq_earth</span><span class="p">));</span>

      <span class="kr">float</span> <span class="nx">thc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">thc_atmosphere</span> <span class="o">-</span> <span class="nx">thc_earth</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.12</span><span class="p">;</span> <span class="c1">// 0.01 - density factor</span>
      <span class="nx">atmosphereThickness</span> <span class="o">=</span> <span class="nx">thc</span><span class="p">;</span>

      <span class="c1">// 3. the normal light calculation</span>
      <span class="nx">vLightDirection</span> <span class="o">=</span> <span class="nx">mat3</span><span class="p">(</span><span class="nx">viewMatrix</span><span class="p">)</span> <span class="o">*</span> <span class="nx">lightDirection</span><span class="p">;</span>
      <span class="nx">vNormalEyeSpace</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">normalMatrix</span> <span class="o">*</span> <span class="nx">normal</span><span class="p">);</span>

    <span class="p">}</span>


  <span class="nt">&lt;/script&gt;</span>

  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"x-shader/x-fragment"</span> <span class="na">id=</span><span class="s">"atmosphereFragmentShader"</span><span class="nt">&gt;</span>

    <span class="nx">varying</span> <span class="kr">float</span> <span class="nx">atmosphereThickness</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vLightDirection</span><span class="p">;</span>
    <span class="nx">varying</span> <span class="nx">vec3</span> <span class="nx">vNormalEyeSpace</span><span class="p">;</span>

    <span class="k">void</span> <span class="nx">main</span><span class="p">(){</span>

      <span class="nx">vec3</span> <span class="nx">lightDir</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">vLightDirection</span><span class="p">);</span>
      <span class="nx">vec3</span> <span class="nx">normal</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">vNormalEyeSpace</span><span class="p">);</span>

      <span class="c1">// computing the light intensity as it is scattered through the atmosphere</span>
      <span class="c1">// based on actual lighting extended a bit</span>
      <span class="c1">// and the thickess</span>
      <span class="kr">float</span> <span class="nx">lightIntensity</span> <span class="o">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">dot</span><span class="p">(</span><span class="nx">normal</span><span class="p">,</span> <span class="nx">lightDir</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">);</span>
      <span class="nx">gl_FragColor</span> <span class="o">=</span> <span class="nx">vec4</span><span class="p">(</span> <span class="p">(</span><span class="nx">vec3</span><span class="p">(</span><span class="mf">57.0</span><span class="p">,</span> <span class="mf">97.0</span><span class="p">,</span> <span class="mf">162.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">256.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="nx">lightIntensity</span><span class="p">),</span> <span class="nx">atmosphereThickness</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>And that was my first play with WebGL and ThreeJS. I will soon publish the demo somewhere but might not work on my video cards.</p>

<p><img src="https://alexandrugris.github.io/assets/webgl_4.png" alt="Earth" /></p>

<p><img src="https://alexandrugris.github.io/assets/webgl_5.png" alt="Earth" /></p>

<p><img src="https://alexandrugris.github.io/assets/webgl_6.png" alt="Earth" /></p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
