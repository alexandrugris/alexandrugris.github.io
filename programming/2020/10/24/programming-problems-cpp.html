<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Programming Problems In C++</title>
  <meta name="description" content="This post is a collection of several programming problems implemented in C++. It’s good to keep the edge sharp by solving some algorithmic problems from time...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/programming/2020/10/24/programming-problems-cpp.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Programming Problems In C++</h1>
    <p class="post-meta"><time datetime="2020-10-24T09:15:16+02:00" itemprop="datePublished">Oct 24, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This post is a collection of several programming problems implemented in C++. It’s good to keep the edge sharp by solving some algorithmic problems from time to time.</p>

<p>Here are all the problems running in the same executable file:</p>

<p><img src="https://alexandrugris.github.io/assets/prog_cpp.png" alt="Running Problems" /></p>

<h3 id="problem-1---zero-or-one-edits-away">Problem 1 - Zero Or One Edits Away</h3>

<p>Write an algorithm that will return true if a string is zero or one edits away from another string. An edit is a letter changed or deleted. The algorithm should be invoked as:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Zero or one edit: "</span> <span class="o">&lt;&lt;</span> <span class="n">zero_one_edits_away</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>or</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Zero or one edit: "</span> <span class="o">&lt;&lt;</span> <span class="n">zero_one_edits_away</span><span class="p">(</span><span class="s">"helo"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>and both should return true.</p>

<p>The solution below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">zero_one_edits_away</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">l1</span> <span class="o">-</span> <span class="n">l2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">edit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">edit_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">else</span> <span class="n">edit_count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">==</span> <span class="n">l2</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="p">)</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// it can only be a delete</span>
		<span class="k">else</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-2---string-rotation">Problem 2 - String Rotation</h3>

<p>Write an algorithm that, given two strings, will return true if one string is a rotation of the other one and false otherwise. The algorithm should be invoked as:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is rotation: "</span> <span class="o">&lt;&lt;</span> <span class="n">is_rotation</span><span class="p">(</span><span class="s">"wwaterbottleww"</span><span class="p">,</span> <span class="s">"bottlewwwwater"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>and in the case above should return true. The solution written below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">is_rotation</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	
	<span class="kt">int</span> <span class="n">start_of_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start_of_match</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">j</span> <span class="o">-=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">start_of_match</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">start_of_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start_of_match</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
			<span class="n">start_of_match</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// last part of the string matched</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">start_of_match</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	
	<span class="c1">// check the first part</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cs1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cs2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">cs1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">cs2</span><span class="p">,</span> <span class="n">start_of_match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-3---remove-duplicates">Problem 3 - Remove Duplicates</h3>

<p>Given a list of of numbers, remove duplicates without breaking the order in the list. The algorithm should be invoked as:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">remove_duplicates</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">});</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">l</span> <span class="o">:</span> <span class="n">lst</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and it should print <code class="language-plaintext highlighter-rouge">1, 2, 3</code>.</p>

<p>The constraint to not break the order does not allow us to sort the list before removal of the duplicates, which forces us into a <code class="language-plaintext highlighter-rouge">O(n^2)</code> solution. We are going to use the <code class="language-plaintext highlighter-rouge">std::list</code> structure which allows in-place removal of an element without breaking the iterators. Since <code class="language-plaintext highlighter-rouge">std::list</code> is doubly linked, another slightly lighter solution could involve the <code class="language-plaintext highlighter-rouge">std::forward_list</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">auto</span> <span class="nf">remove_duplicates</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span><span class="n">j</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">==</span> <span class="o">*</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lst</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">lst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-4---k-to-last">Problem 4 - K-to-last</h3>

<p>Write an algorithm which prints the k-to-last element in a singly linked list. Since we don’t know the number of elements in the list, nor can we traverse it backwards, we need to parse the whole list and keep two pointers at k elements apart. The algorithm should be invoked as:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">k_to_last</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="s">" to last is "</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"k &gt; length(array)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The solution:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">k_to_last</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">k_upd</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k_upd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">it1</span><span class="o">++</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">it1</span> <span class="o">==</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k_upd</span><span class="p">)</span> 
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// not enough elements</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it1</span><span class="o">++</span><span class="p">,</span> <span class="n">it2</span><span class="o">++</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="n">it2</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-5---build-dependencies">Problem 5 - Build Dependencies</h3>

<p>Given a list of builds, with dependencies between each other, write a program that finds the right compilation order such that each dependency is compiled before its dependents. Here is the example invocation, with first build depending on the builds sent as the second parameter.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"BUILD DEPENDENCIES"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">dependencies</span><span class="p">;</span> 

<span class="n">dependencies</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">({</span> <span class="sc">'d'</span> <span class="p">}));</span>
<span class="n">dependencies</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="sc">'f'</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">({</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">}));</span>
<span class="n">dependencies</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="sc">'b'</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">({</span> <span class="sc">'d'</span> <span class="p">}));</span>
<span class="n">dependencies</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="sc">'d'</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">({</span> <span class="sc">'c'</span> <span class="p">}));</span>
<span class="n">dependencies</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="sc">'g'</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">({</span> <span class="p">}));</span>

<span class="n">make_builds</span><span class="p">(</span><span class="n">dependencies</span><span class="p">);</span>

<span class="k">try</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">l</span> <span class="o">:</span> <span class="n">build_dependencies</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">exx</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">exx</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">clear_builds</span><span class="p">();</span>
</code></pre></div></div>

<p>In this case, the printed solution should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BUILD DEPENDENCIES
c
e
g
d
a
b
f
</code></pre></div></div>

<p>The algorithm below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">BuildState</span> <span class="p">{</span>
	<span class="n">NOT_TOUCHED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">UNDER_CHECK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CAN_BE_BUILT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">build</span> <span class="p">{</span>

	<span class="n">build</span><span class="p">(</span><span class="kt">char</span> <span class="n">_id</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">id</span><span class="p">(</span><span class="n">_id</span><span class="p">),</span>
		<span class="n">build_state</span><span class="p">(</span><span class="n">NOT_TOUCHED</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="p">}</span>

	<span class="kt">char</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">BuildState</span> <span class="n">build_state</span><span class="p">;</span>
	<span class="n">list</span><span class="o">&lt;</span><span class="n">build</span><span class="o">*&gt;</span> <span class="n">dependencies</span><span class="p">;</span>

<span class="p">};</span>

<span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">build</span><span class="o">*&gt;</span> <span class="n">builds</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">make_builds</span><span class="p">(</span><span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prjs</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">:</span> <span class="n">prjs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">builds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">builds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
			<span class="n">it</span> <span class="o">=</span> <span class="n">builds</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="k">new</span> <span class="n">build</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">d</span> <span class="o">:</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">auto</span> <span class="n">dps</span> <span class="o">=</span> <span class="n">builds</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dps</span> <span class="o">==</span> <span class="n">builds</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
				<span class="n">dps</span> <span class="o">=</span> <span class="n">builds</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">new</span> <span class="n">build</span><span class="p">(</span><span class="n">d</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>

			<span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dps</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">clear_builds</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">b</span> <span class="o">:</span> <span class="n">builds</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
		<span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">builds</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">build_dependencies</span><span class="p">(</span><span class="k">const</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">build</span><span class="o">*&gt;&amp;</span> <span class="n">projects</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>

	<span class="c1">// start building in parallel those that don't have dependencies</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">projects</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">==</span> <span class="n">CAN_BE_BUILT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">==</span> <span class="n">UNDER_CHECK</span><span class="p">)</span>
			<span class="k">throw</span> <span class="s">"cannot build - circular dependencies"</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">=</span> <span class="n">CAN_BE_BUILT</span><span class="p">;</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// finish with the rest of them</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">projects</span><span class="p">)</span> <span class="p">{</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">==</span> <span class="n">CAN_BE_BUILT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">==</span> <span class="n">UNDER_CHECK</span><span class="p">)</span>
			<span class="k">throw</span> <span class="s">"cannot build - circular dependencies"</span><span class="p">;</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">=</span> <span class="n">UNDER_CHECK</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">d</span> <span class="o">:</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">build_dependencies</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">);</span>
			<span class="n">copy</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">build_state</span> <span class="o">=</span> <span class="n">CAN_BE_BUILT</span><span class="p">;</span>
		<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">list</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">build_dependencies</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">list</span><span class="o">&lt;</span><span class="n">build</span><span class="o">*&gt;</span> <span class="n">prjs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">b</span> <span class="o">:</span> <span class="n">builds</span><span class="p">)</span>
		<span class="n">prjs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">build_dependencies</span><span class="p">(</span><span class="n">prjs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-6---recursive-multiply">Problem 6 - Recursive Multiply</h3>

<p>Write a program that performs multiplication without using the <code class="language-plaintext highlighter-rouge">*</code> symbol while minimizing the number of operations. The only allowed operators are <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// recursive multiply without using *, just +, -, &lt;&lt;, &gt;&gt;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">recursive_multiply</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">24</span><span class="p">);</span>
</code></pre></div></div>

<p>The solution below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">recursive_multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// take the largest number to add</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b_first</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

	<span class="k">for</span> <span class="p">(;</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span> 

	<span class="n">b</span> <span class="o">=</span> <span class="n">b_first</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">recursive_multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-7---all-permutations-no-duplicates">Problem 7 - All Permutations, No Duplicates</h3>

<p>Given a string, write all possible permutations of that string elimiating duplicates. For instance, for the following invocation,</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// permutations without duplicates</span>
<span class="n">all_permutations_no_duplicates</span><span class="p">(</span><span class="s">"aaaab"</span><span class="p">);</span>
</code></pre></div></div>

<p>the printed solution should be:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a, a, a, a, b,
a, a, a, b, a,
a, a, b, a, a,
a, b, a, a, a,
b, a, a, a, a,
</code></pre></div></div>

<p>The solution involves keeping the count of each duplicated letter so we don’t include it as a different symbol for each permutation:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">all_permutations_no_duplicates</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">,</span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">counts</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">any</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// can be done with forward_list&lt;&gt; insert and erase @ it</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">--</span><span class="p">;</span>
			<span class="n">all_permutations_no_duplicates</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">counts</span><span class="p">);</span>
			<span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">current</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
			<span class="n">any</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">any</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">current</span><span class="p">)</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span><span class="p">;</span>

		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">all_permutations_no_duplicates</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str_</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnts</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">str_</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

	<span class="c1">// build counts</span>
	<span class="kt">char</span> <span class="n">prev_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev_c</span> <span class="o">!=</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">cnts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">cnts</span><span class="p">[</span><span class="n">cnts</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev_c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="n">all_permutations_no_duplicates</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">cnts</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-8---stacks-of-boxes">Problem 8 - Stacks of Boxes</h3>

<p>Given a list of boxes, find the highest tower that can be built by stacking boxes on top of each other. A box can be stacked on top of another box only if all its dimensions, width, depth and height, are smaller than those of the box below.</p>

<p>For solving the problem we will start by generating an array of 100 boxes, all with randomly generated dimensions.</p>

<p>The algorithm is started by:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stack_of_boxes</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>The solution below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Box</span> <span class="p">{</span>
	<span class="n">Box</span><span class="p">(</span><span class="kt">int</span> <span class="n">w_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h_</span><span class="p">)</span> <span class="o">:</span> <span class="n">w</span><span class="p">(</span><span class="n">w_</span><span class="p">),</span> <span class="n">l</span><span class="p">(</span><span class="n">l_</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">h_</span><span class="p">){</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>

	<span class="kt">bool</span> <span class="n">sorter</span><span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">bool</span> <span class="n">can_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Stack</span> <span class="p">{</span>

	<span class="n">Stack</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;</span> <span class="n">next_</span><span class="p">)</span> <span class="o">:</span> <span class="n">base_box</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span> <span class="p">{}</span>

	<span class="kt">int</span> <span class="n">base_box</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">stack_sorted_boxes</span><span class="p">(</span>
		<span class="n">list</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;&gt;&amp;</span> <span class="n">s</span><span class="p">,</span> 
		<span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> 
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">can_stack</span><span class="p">,</span> 
		<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">bool</span> <span class="n">added</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// it is basically a deque</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>

		<span class="k">auto</span> <span class="n">stackables</span> <span class="o">=</span> <span class="n">can_stack</span><span class="p">.</span><span class="n">find</span><span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base_box</span><span class="p">);</span>
		
		<span class="c1">// cannot stack anything on top, this is the end of the stack</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stackables</span> <span class="o">==</span> <span class="n">can_stack</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">max_height</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">)</span>
				<span class="n">max_height</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">:</span> <span class="n">stackables</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// here we don't really need the last parameter</span>
				<span class="c1">// if we are only returning the stack height and not the stask itself</span>
				<span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// I already put something on top of it</span>

		<span class="n">added</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max_height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">stack_of_boxes</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

	<span class="c1">// randomly generate 100 boxes</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">b1</span><span class="p">.</span><span class="n">sorter</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
		<span class="p">});</span>

	<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">can_stack</span><span class="p">;</span>

	<span class="c1">// generate a list of boxes that can be stacked upon each other</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">can_stack</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
				<span class="n">can_stack</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">list</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;&gt;</span> <span class="n">stacks</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stacks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Stack</span><span class="o">&gt;</span><span class="p">()));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">stack_sorted_boxes</span><span class="p">(</span><span class="n">stacks</span><span class="p">,</span> <span class="n">can_stack</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="problem-9---expression-equivalence">Problem 9 - Expression Equivalence</h3>

<p>Given two expressions, <code class="language-plaintext highlighter-rouge">a * (b + c)</code> and <code class="language-plaintext highlighter-rouge">a * b + a * c</code>, write an algorithm that will determine if the two expressions are equivalent. In our case above, the two expressions are equivalent.</p>

<p>The solution implies expanding the parantheses and bringing the expression to a cannonical form, a sum of products. To shortcut the parsing, we will consider the expression is given in the form of an expression tree, <code class="language-plaintext highlighter-rouge">(left operand, operation, right operand)</code>. After the expression is brought to the cannonical form, each term is sorted alphabetically and then all all terms are again sorted. Then we simply compare the strings in order to decide whether the two expressions are equivalent.</p>

<p>The algorithm is started by defining expressions as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ExprTree</span> <span class="nf">e1</span><span class="p">(</span>
		<span class="sc">'*'</span><span class="p">,</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">),</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'a'</span><span class="p">)),</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">),</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'a'</span><span class="p">))</span>
	<span class="p">);</span>

<span class="n">ExprTree</span> <span class="nf">e2</span><span class="p">(</span>
		<span class="sc">'*'</span><span class="p">,</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">),</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">)</span>
	<span class="p">);</span>

<span class="n">ExprTree</span> <span class="nf">e3</span><span class="p">(</span>
		<span class="sc">'*'</span><span class="p">,</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span>
			<span class="sc">'*'</span><span class="p">,</span>
			<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">),</span>
			<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">)</span>
		<span class="p">),</span>
		<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span>
			<span class="sc">'*'</span><span class="p">,</span>
			<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">),</span>
			<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">)</span>
		<span class="p">)</span>
	<span class="p">);</span>

<span class="c1">// or creating a random tree for faster testing</span>
<span class="n">ExprTree</span><span class="o">*</span> <span class="n">e4</span> <span class="o">=</span> <span class="n">ExprTree</span><span class="o">::</span><span class="n">make_random_tree</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">expression_equivalence</span><span class="p">(</span><span class="n">e4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">e4</span>
</code></pre></div></div>

<p>As a complication, the algorithm must not generate any memory leaks and must use C-style pointers.</p>

<p>Below is the full solution:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">ExprTree</span> <span class="p">{</span>

	<span class="n">ExprTree</span><span class="p">(</span><span class="kt">char</span> <span class="n">_op</span><span class="p">,</span> <span class="n">ExprTree</span><span class="o">*</span> <span class="n">_left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">ExprTree</span><span class="o">*</span> <span class="n">_right</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">op</span><span class="p">(</span><span class="n">_op</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">_left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">_right</span><span class="p">){</span>
	<span class="p">}</span>

	<span class="n">ExprTree</span><span class="p">(</span><span class="kt">char</span> <span class="n">_op</span><span class="p">,</span> <span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">_op</span><span class="p">;</span>
		<span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
		<span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">ExprTree</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
			<span class="k">delete</span> <span class="n">left</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
			<span class="k">delete</span> <span class="n">right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ExprTree</span><span class="o">*</span> <span class="n">deep_copy</span><span class="p">()</span> <span class="p">{</span>

		<span class="k">return</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> 
			<span class="n">left</span> <span class="o">?</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">()</span> <span class="o">:</span> <span class="nb">nullptr</span><span class="p">,</span> 
			<span class="n">right</span> <span class="o">?</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">()</span> <span class="o">:</span> <span class="nb">nullptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// utility function to generate a random tree</span>
	<span class="c1">// not part of the algorithm</span>
	<span class="k">static</span> <span class="n">ExprTree</span><span class="o">*</span> <span class="n">make_random_tree</span><span class="p">()</span> <span class="p">{</span>

		<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">RAND_MAX</span><span class="p">);</span>

		 <span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">)</span>
			 <span class="k">return</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>

		 <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="mf">0.6</span><span class="p">)</span>
			 <span class="k">return</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
		 
		 <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">)</span>
			 <span class="k">return</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">make_random_tree</span><span class="p">(),</span> <span class="n">make_random_tree</span><span class="p">());</span>

		 <span class="k">return</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span> <span class="n">make_random_tree</span><span class="p">(),</span> <span class="n">make_random_tree</span><span class="p">());</span>

	<span class="p">}</span>

	<span class="kt">char</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">ExprTree</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">ExprTree</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">expand_paranthesis</span><span class="p">(</span><span class="n">ExprTree</span><span class="o">*</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">'+'</span> <span class="o">&amp;&amp;</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="sc">'*'</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="c1">// terminal symbol</span>

	<span class="c1">// we need to start with the recursion condition in order</span>
	<span class="c1">// to bubble up the +'es. we cannot have a * above a +</span>
	<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
	<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">auto</span> <span class="n">tmpop</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>

		<span class="c1">// (a + b) * (a + b) </span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">&amp;&amp;</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="sc">'+'</span><span class="p">;</span>
			
			<span class="k">auto</span> <span class="n">tmp_left_a</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">tmp_right_a</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">tmp_left_b</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">tmp_right_b</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

			<span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span>
				<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp_left_a</span><span class="p">,</span> <span class="n">tmp_right_a</span><span class="p">),</span>
				<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp_left_a</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">(),</span> <span class="n">tmp_right_b</span><span class="p">));</span>

			<span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'+'</span><span class="p">,</span>
				<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp_left_b</span><span class="p">,</span> <span class="n">tmp_right_a</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">()),</span>
				<span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp_left_b</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">(),</span> <span class="n">tmp_right_b</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">()));</span>
		<span class="p">}</span>
		<span class="c1">// a * (b + c)</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="sc">'+'</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">deep_copy_left</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">();</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">deep_copy_left</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">//(b + c) * a</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="sc">'+'</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">start_right_copy</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">deep_copy</span><span class="p">();</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
			<span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExprTree</span><span class="p">(</span><span class="sc">'*'</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">start_right_copy</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// what has been arranged before is </span>
		<span class="c1">// no longer arranged because we changed the structure of the tree</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpop</span> <span class="o">!=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
			<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">get_set</span><span class="p">(</span><span class="n">ExprTree</span><span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_set</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">get_set</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">to_sorted_vector</span><span class="p">(</span><span class="n">ExprTree</span><span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to_sorted_vector</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">to_sorted_vector</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

		<span class="n">get_set</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
		<span class="n">get_set</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

		<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		<span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
		<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">expression_equivalence</span><span class="p">(</span><span class="n">ExprTree</span><span class="o">*</span> <span class="n">e1</span><span class="p">,</span> <span class="n">ExprTree</span><span class="o">*</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span>
	<span class="n">expand_paranthesis</span><span class="p">(</span><span class="n">e2</span><span class="p">);</span>
	
	<span class="c1">// each term is sorted alphabetically</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">e1_str</span><span class="p">;</span>
	<span class="n">to_sorted_vector</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e1_str</span><span class="p">);</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">e2_str</span><span class="p">;</span>
	<span class="n">to_sorted_vector</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e2_str</span><span class="p">);</span>

	<span class="c1">// all terms are sorted alphabetically</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">e1_str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e1_str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">e2_str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e2_str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

	<span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">e1_str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">e2_str</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	<span class="c1">// simple pairwise comparison</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">e1_str</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">it2</span> <span class="o">!=</span> <span class="n">e2_str</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it1</span><span class="o">++</span><span class="p">,</span> <span class="n">it2</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it1</span> <span class="o">!=</span> <span class="o">*</span><span class="n">it2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">it1</span> <span class="o">==</span> <span class="n">e1_str</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">it2</span> <span class="o">==</span> <span class="n">e2_str</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Below you can see the algorithm running in Visual C++ with the expression expanded. You can notice that all <code class="language-plaintext highlighter-rouge">+</code>-es are above <code class="language-plaintext highlighter-rouge">*</code> in the reorganized expression tree.</p>

<p><img src="https://alexandrugris.github.io/assets/prog_cpp2.jpg" alt="Expanded Cannonical Expression" /></p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
