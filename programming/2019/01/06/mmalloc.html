<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MMalloc</title>
  <meta name="description" content="A small, few hours project, which started from the idea of creating an allocator for persistent memory that can be used to load existing memory structures fr...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/programming/2019/01/06/mmalloc.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">MMalloc</h1>
    <p class="post-meta"><time datetime="2019-01-06T12:15:16+01:00" itemprop="datePublished">Jan 6, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>A small, few hours project, which started from the idea of creating an allocator for persistent memory that can be used to load existing memory structures from disk on process restart. It never got that far in the few hours spent on it, but it was fun to write so here it goes. Clearly, not something that I would ever put in a production project, as any memory corruption would propagate after process restart, but the idea of a location independent allocator is fun nevertheless.</p>

<h3 id="header-file">Header File:</h3>

<p>heap.c - comments are somewhat self explanatory</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  heap.h</span>
<span class="c1">//  mmalloc</span>
<span class="c1">//</span>
<span class="c1">//  Created by Alexandru Gris on 1/6/19.</span>
<span class="c1">//  Copyright © 2019 Alexandru Gris. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#ifndef heap_h
#define heap_h
</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span>
<span class="cm">/* Index generates the amount of objects that can be stored in this allocator; eg. typeof(Index) == unsigned char =&gt; 256
AllocUnit generates the minimum size an object can have; e.g. typeof(AllocUnit) == int, minimum block that can be allocated is int and, together with the char above, we can address a maximum of 256 * sizeof(int) bytes.
alloc_size is the size of the block, number of AllocUnits in this block
MaxBlockCountType -&gt; how many AllocUnits are in this block. Can be set to lower than AllocUnit; AllocUnit will allow a single allocation for the whole memory */</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">AllocUnit</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Index</span><span class="p">,</span> <span class="k">class</span> <span class="nc">MaxBlockCountType</span> <span class="o">=</span> <span class="n">AllocUnit</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">mem_loc</span><span class="p">{</span>
    
    <span class="n">MaxBlockCountType</span> <span class="n">alloc_size</span><span class="p">;</span>
    <span class="n">Index</span> <span class="n">alloc_index</span><span class="p">;</span>
    
    <span class="n">mem_loc</span><span class="p">(</span><span class="n">MaxBlockCountType</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">alloc_size</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">alloc_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="kt">bool</span> <span class="n">valid</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">alloc_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="n">alloc_index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AllocUnit</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">invalidate</span><span class="p">(){</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">alloc_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">mem_heap</span><span class="p">{</span>
    
<span class="nl">private:</span>
    <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;*</span> <span class="n">mem</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mem_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
<span class="nl">public:</span>
    
    <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mem_loc</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">;</span>
    
    <span class="n">mem_heap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_size</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">mem</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">block</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">)),</span>
        <span class="n">mem_size</span><span class="p">(</span><span class="n">_size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)),</span>
        <span class="n">heap_size</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span>
            
        <span class="p">}</span>
    
    <span class="o">~</span><span class="n">mem_heap</span><span class="p">(){</span>
        <span class="n">mem_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">bubble_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">c_heap</span><span class="p">,</span> <span class="k">const</span> <span class="n">block</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">p_heap</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">c_heap</span><span class="p">);</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">c_heap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">block</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">(</span><span class="n">p_heap</span><span class="p">)){</span>
            <span class="n">mem</span><span class="p">[</span><span class="n">c_heap</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">p_heap</span><span class="p">];</span>
            <span class="n">c_heap</span> <span class="o">=</span> <span class="n">p_heap</span><span class="p">;</span>
            <span class="n">p_heap</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">c_heap</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">mem</span><span class="p">[</span><span class="n">c_heap</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">c_heap</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="cm">/**
     * Returns false if the memory allocated for the heap is exceeded.
     */</span>
    <span class="kt">bool</span> <span class="n">add_free</span><span class="p">(</span><span class="k">const</span> <span class="n">block</span><span class="o">&amp;</span> <span class="n">block</span><span class="p">){</span>
        
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="n">heap_size</span><span class="o">++</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">heap_size</span> <span class="o">&gt;</span> <span class="n">mem_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        
        <span class="n">bubble_up</span><span class="p">(</span><span class="n">heap_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
        
        <span class="n">assert</span><span class="p">(</span><span class="n">is_heap</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">src_subtree</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">heap_size</span><span class="p">)</span> <span class="k">return</span> <span class="n">heap_size</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">alloc_size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">k_left</span> <span class="o">=</span> <span class="n">src_subtree</span><span class="p">(</span><span class="n">lft_child</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">k_right</span> <span class="o">=</span> <span class="n">src_subtree</span><span class="p">(</span><span class="n">rght_child</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">k_left</span> <span class="o">==</span> <span class="n">heap_size</span> <span class="o">&amp;&amp;</span> <span class="n">k_right</span> <span class="o">==</span> <span class="n">heap_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">heap_size</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">k_left</span> <span class="o">==</span> <span class="n">heap_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">k_right</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">k_right</span> <span class="o">==</span> <span class="n">heap_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">k_left</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">v</span><span class="p">(</span><span class="n">k_left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">(</span><span class="n">k_right</span><span class="p">)</span><span class="o">?</span> <span class="n">k_left</span> <span class="o">:</span> <span class="n">k_right</span><span class="p">;</span>
        
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">lft_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">rght_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">parent</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">mem</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">alloc_size</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">has_lft</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">lft_child</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">heap_size</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">has_rght</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">rght_child</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">heap_size</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">last</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="n">heap_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">is_leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">heap_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_lft</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="n">is_heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
        
<span class="cp">#ifdef __DEBUG
</span>        <span class="k">if</span><span class="p">(</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">(</span><span class="n">lft_child</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">has_rght</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
           <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">is_heap</span><span class="p">(</span><span class="n">lft_child</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">is_heap</span><span class="p">(</span><span class="n">rght_child</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
<span class="cp">#else
</span>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span>        
    <span class="p">}</span>
    
    <span class="k">const</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">){</span>
        
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">src_subtree</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">heap_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// invalid</span>

        <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">lst</span> <span class="o">=</span> <span class="o">--</span><span class="n">heap_size</span><span class="p">;</span>
        
        <span class="n">k</span> <span class="o">=</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">lst</span><span class="p">]);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">k</span><span class="p">)){</span>
            
            <span class="kt">int</span> <span class="n">mn</span> <span class="o">=</span> <span class="p">(</span><span class="n">has_rght</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">(</span><span class="n">rght_child</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">(</span><span class="n">lft_child</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span><span class="o">?</span> <span class="n">rght_child</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">:</span> <span class="n">lft_child</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
            
            <span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">mn</span><span class="p">];</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">mn</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="n">mem</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">lst</span><span class="p">];</span>
        
<span class="cp">#ifdef __DEBUG
</span>        <span class="n">mem</span><span class="p">[</span><span class="n">heap_size</span><span class="p">].</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">is_heap</span><span class="p">());</span>
<span class="cp">#endif
</span>        
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">AllocUnit</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Index</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Type</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">mem_loc_t</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span><span class="p">{</span>
    
<span class="nl">public:</span>
    
    <span class="n">mem_loc_t</span><span class="p">(</span><span class="k">const</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;&amp;</span>  <span class="n">m</span><span class="p">){</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">alloc_size</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">alloc_index</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">alloc_index</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Type</span><span class="o">*</span> <span class="n">ptr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">base</span><span class="p">){</span>
        <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;::</span><span class="n">ptr</span><span class="p">(</span><span class="n">base</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">AllocUnit</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Index</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">allocator</span><span class="p">{</span>
    
<span class="nl">private:</span>
    
    <span class="n">mem_heap</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span> <span class="n">heap</span><span class="p">;</span>
    
    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mem</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mem_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mem_idx</span><span class="p">;</span>
    
<span class="nl">public:</span>
    
    <span class="n">allocator</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_mem_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_heap_size</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">heap</span><span class="p">(</span><span class="n">_heap</span><span class="p">,</span> <span class="n">_heap_size</span><span class="p">),</span>
              <span class="n">mem</span><span class="p">(</span><span class="n">_mem</span><span class="p">),</span>
              <span class="n">mem_size</span><span class="p">(</span><span class="n">_mem_size</span><span class="p">),</span>
              <span class="n">mem_idx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">_mem</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">_mem_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_heap</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">_heap_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">O</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">CtorP</span><span class="p">&gt;</span> <span class="n">mem_loc_t</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">O</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">(</span><span class="k">const</span> <span class="n">CtorP</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">){</span>
        
        <span class="c1">// TODO: if cnt &gt; 1 add a new int to the front of the allocated array so that I can call delete[] on them.</span>
        
        <span class="kt">int</span> <span class="n">size_in_alloc_units</span> <span class="o">=</span> <span class="n">bytes_to_alloc_units</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">O</span><span class="p">)</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">size_in_alloc_units</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">.</span><span class="n">valid</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="mi">6</span> <span class="o">*</span> <span class="n">size_in_alloc_units</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mem_idx</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">mem_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">alloc_extend_heap</span><span class="p">(</span><span class="n">size_in_alloc_units</span><span class="p">);</span>
        
        <span class="c1">// invoke constructors</span>
        <span class="k">auto</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">mem_loc_t</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">O</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        
        <span class="n">O</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">loc</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
            <span class="k">new</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="n">O</span><span class="p">(</span><span class="n">params</span><span class="p">...);</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">loc</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span> <span class="n">alloc_extend_heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">size_in_alloc_units</span><span class="p">){</span>
        
        <span class="kt">int</span> <span class="n">size_in_bytes</span> <span class="o">=</span> <span class="n">alloc_units_to_bytes</span><span class="p">(</span><span class="n">size_in_alloc_units</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">mem_idx</span> <span class="o">+</span> <span class="n">size_in_bytes</span> <span class="o">&gt;</span> <span class="n">mem_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// nullptr</span>
        
        <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">mem_idx</span><span class="p">;</span>
        <span class="n">mem_idx</span> <span class="o">+=</span> <span class="n">size_in_bytes</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">mem_loc</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="o">&gt;</span><span class="p">(</span><span class="n">size_in_alloc_units</span><span class="p">,</span> <span class="n">debase</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">bytes_to_alloc_units</span><span class="p">(</span><span class="kt">int</span> <span class="n">bytes</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">bytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AllocUnit</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">alloc_units_to_bytes</span><span class="p">(</span><span class="kt">int</span> <span class="n">alloc_units</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">alloc_units</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AllocUnit</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">Index</span> <span class="n">debase</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">-</span> <span class="n">mem</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AllocUnit</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">O</span><span class="p">&gt;</span><span class="kt">void</span> <span class="n">free</span><span class="p">(</span><span class="n">mem_loc_t</span><span class="o">&lt;</span><span class="n">AllocUnit</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">O</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">){</span>
        
        <span class="c1">// TODO: call destructors, if array, implement also []</span>
        <span class="c1">// Warning - now only calls the destructor for the first element</span>
        <span class="n">l</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">O</span><span class="p">();</span>
        
        <span class="n">heap</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
        <span class="n">l</span><span class="p">.</span><span class="n">invalidate</span><span class="p">();</span>
    <span class="p">}</span>
        
<span class="p">};</span>


<span class="cp">#endif </span><span class="cm">/* heap_h */</span><span class="cp">
</span></code></pre></div></div>

<h3 id="usage">Usage</h3>

<p>main.cpp</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">//  main.cpp</span>
<span class="c1">//  mmalloc</span>
<span class="c1">//</span>
<span class="c1">//  Created by Alexandru Gris on 1/5/19.</span>
<span class="c1">//  Copyright © 2019 Alexandru Gris. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#define __DEBUG
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">"heap.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    

    <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    
    <span class="p">{</span>
        <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
        
        <span class="n">mem_heap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">h</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
        
        <span class="c1">// here we test the mem_heap class</span>
        <span class="c1">// we add some free blocks to see that, indeed, the correct size is found</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>
        <span class="n">h</span><span class="p">.</span><span class="n">add_free</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">::</span><span class="n">block</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">));</span>

        <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="n">ret</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="n">ret</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="n">ret</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">alloc_size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
    <span class="p">}</span>
    
    <span class="p">{</span>
        <span class="c1">// here we test the actual allocator</span>
        <span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="mi">768</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
        
        <span class="k">auto</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m2</span><span class="p">);</span>
        
        <span class="k">auto</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">m4</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
        
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m2</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m3</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m4</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">m5</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="n">a</span><span class="p">.</span><span class="n">free</span><span class="p">(</span><span class="n">m5</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    <span class="k">delete</span><span class="p">[]</span> <span class="n">mem</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
