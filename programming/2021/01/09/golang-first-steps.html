<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>First Steps In Go</title>
  <meta name="description" content="My first steps in Go, largely based on the Golang tutorial and Internet side searches.">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/programming/2021/01/09/golang-first-steps.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">First Steps In Go</h1>
    <p class="post-meta"><time datetime="2021-01-09T08:15:16+01:00" itemprop="datePublished">Jan 9, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>My first steps in Go, largely based on the Golang tutorial and Internet side searches.</p>

<h3 id="hello-world">Hello World</h3>

<p>Building a very basic hello world project once the go tools are installed is straight forward:</p>

<ul>
  <li>Create a folder named “helloworld”</li>
  <li><code class="language-plaintext highlighter-rouge">cd ./helloworld</code></li>
  <li>Create a file called <code class="language-plaintext highlighter-rouge">main.go</code></li>
  <li>Add the following code into the file</li>
  <li>Save and at the command prompt type <code class="language-plaintext highlighter-rouge">go build</code>. An executable file called <code class="language-plaintext highlighter-rouge">helloworld</code> will be compiled into the folder.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A good editor for <code class="language-plaintext highlighter-rouge">go</code> is Visual Studio Code.</p>

<h3 id="language-basics">Language Basics</h3>

<p>The most basic unit of organizing code in go is the function. Below is an example of a function with several parameters, one of each being a callback (function pointer).</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// function receiving function as a parameter</span>
<span class="k">func</span> <span class="n">arrayOpScalar</span><span class="p">(</span><span class="n">array</span> <span class="p">[]</span><span class="kt">float32</span><span class="p">,</span> <span class="n">constant</span> <span class="kt">float32</span><span class="p">,</span> <span class="n">operation</span> <span class="k">func</span><span class="p">(</span><span class="kt">float32</span><span class="p">,</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">array</span> <span class="p">{</span>
		<span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">operation</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">constant</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A function can be passed as a parameter, assigned to a variable or returned from another function.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// use the arrayOpScalar function defined above to </span>
<span class="c">// create another function to double the values in an array</span>
<span class="n">doubleFn</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">array</span> <span class="p">[]</span><span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arrayOpScalar</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">float32</span><span class="p">)</span> <span class="kt">float32</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="p">})</span>
	<span class="p">}</span>

<span class="n">doubleFn</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p>But before we do that, let’s look a bit at arrays and slices. Allocating an array goes like this</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="m">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">13</span><span class="p">}</span>
</code></pre></div></div>

<p>The length is part of the array so it cannot be resized. Slices are views onto arrays, so when a value is modified on the slice it will automatically propagate to the backing array.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">s</span> <span class="p">[]</span><span class="kt">int</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">]</span>
</code></pre></div></div>

<p>The internal structure of a slice is as follows:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">array</span> <span class="o">*</span><span class="n">T</span><span class="p">,</span>
  <span class="nb">len</span> <span class="kt">int</span><span class="p">,</span>
  <span class="nb">cap</span> <span class="kt">int</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Length and capacity can be accessed through <code class="language-plaintext highlighter-rouge">len()</code> and <code class="language-plaintext highlighter-rouge">cap()</code>. Therefore, in golang you can do very cool stuff such as converting from a struct to its underlying byte representation. Such operations are useful when, for instance, memory mapping files to arrays of a specified stucture without additional serialization / deseralization. <a href="https://stackoverflow.com/questions/16330490/in-go-how-can-i-convert-a-struct-to-a-byte-array">Here for an extended thread</a></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Struct</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">p1</span> <span class="kt">int32</span>
  <span class="n">p2</span> <span class="kt">int32</span>
  <span class="n">p3</span> <span class="kt">uint16</span>
  <span class="n">p3</span> <span class="kt">uint16</span>
<span class="p">}</span>

<span class="c">// read in a compile-time constant the size of the struct</span>
<span class="k">const</span> <span class="n">sz</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">SizeOf</span><span class="p">(</span><span class="n">Struct</span><span class="p">{}))</span>

<span class="c">// initialize convert the pointer to the struct to an array of bytes </span>
<span class="c">// of the same size as the struct and take a slice to it.</span>
<span class="k">var</span> <span class="n">asByteSlice</span> <span class="p">[]</span><span class="kt">byte</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">struct_value</span><span class="p">)))[</span><span class="o">:</span><span class="p">]</span>
</code></pre></div></div>

<p>Slices can contain other slices.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mat3x3</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">float32</span><span class="p">{</span>
	<span class="p">[]</span><span class="kt">float32</span><span class="p">{</span><span class="m">1.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">},</span>
	<span class="p">[]</span><span class="kt">float32</span><span class="p">{</span><span class="m">0.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">},</span>
	<span class="p">[]</span><span class="kt">float32</span><span class="p">{</span><span class="m">0.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">},</span>
<span class="p">}</span>
<span class="c">// elements can be accessed</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="m">0</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// dynamic allocation of an array of 10 floats</span>
<span class="n">p</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">float32</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>

<span class="c">// dynamically growing the array by appending</span>
<span class="c">// 10 elements with spread operator</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">float32</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

<span class="c">// looping over indexes in p</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">p</span> <span class="p">{</span>
	<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kt">float32</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s look also at static initialization.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="k">struct</span> <span class="p">{</span> <span class="c">// annonymous struct of two integers</span>
	<span class="n">i1</span> <span class="kt">int</span>
	<span class="n">i2</span> <span class="kt">int</span>
<span class="p">}{</span> <span class="c">// statically initialized</span>
	<span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span>
	<span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">},</span>
	<span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">2</span><span class="p">},</span> <span class="c">// comma at the end is mandatory</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">slice</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v : %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="custom-types">Custom Types</h3>

<p>In <code class="language-plaintext highlighter-rouge">go</code>, encapsulation is defined at the package level. Everything in a package is public. Exported symbols start with capital letter, everything starting with lowercase is private outside of the package. Let’s define a custom type.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">X</span> <span class="kt">float64</span>
	<span class="n">Y</span> <span class="kt">float64</span>
	<span class="n">Z</span> <span class="kt">float64</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Initializing a variable of such a type goes like this:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span> <span class="o">:=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">0.1</span><span class="p">,</span> <span class="m">0.2</span><span class="p">,</span> <span class="m">0.3</span><span class="p">}</span>
</code></pre></div></div>

<p>or</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span> <span class="o">:=</span> <span class="n">Vertex</span> <span class="p">{</span>
<span class="n">X</span> <span class="o">:</span> <span class="m">0.1</span><span class="p">,</span>
<span class="n">Y</span> <span class="o">:</span> <span class="m">0.2</span><span class="p">,</span>
<span class="n">Z</span> <span class="o">:</span> <span class="m">0.3</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can return a pointer of such a struct. By default the compiler will favor stack allocation, but it does perform escape analysis and, in case the lifetime of an object cannot be determined at compile time it will switch to allocating it on the heap.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">returnPointerToVertex</span><span class="p">()</span> <span class="o">*</span><span class="n">Vertex</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">Vertex</span><span class="p">{</span><span class="m">1.0</span><span class="p">,</span> <span class="m">2.0</span><span class="p">,</span> <span class="m">3.0</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now let’s add some methods to the type.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Length computes the vector norm</span>
<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">Vertex</span><span class="p">)</span> <span class="n">Length</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">X</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Y</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Y</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">Z</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Methods with pointer receivers can modify the value to which the receiver points (as scale does here). ince methods often need to modify their receiver, pointer receivers are more common than value receivers. There are two reasons to use a pointer receiver:</p>
<ul>
  <li>The first is so that the method can modify the value that its receiver points to.</li>
  <li>The second is to avoid copying the value on each method call</li>
</ul>

<p>In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Scale scales the vector by a float</span>
<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Scale</span><span class="p">(</span><span class="n">s</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>

  <span class="c">// unlike C++ where invoking a method on a nullptr usually results in a crash</span>
  <span class="c">// in golang this is perfectly acceptable</span>
	<span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Received nill pointer"</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="n">v</span><span class="o">.</span><span class="n">X</span> <span class="o">*=</span> <span class="n">s</span>
	<span class="n">v</span><span class="o">.</span><span class="n">Y</span> <span class="o">*=</span> <span class="n">s</span>
	<span class="n">v</span><span class="o">.</span><span class="n">Z</span> <span class="o">*=</span> <span class="n">s</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Speaking of types, golang does not allow inheritance, but it does have the interface type.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Scaler</span> <span class="k">interface</span> <span class="p">{</span>
  <span class="n">Scale</span><span class="p">(</span><span class="kt">float64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Vector automatically implements this interface by simply implementing the respective methods. Now we can do</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span> <span class="o">:=</span> <span class="n">Vertex</span><span class="p">{</span><span class="n">X</span><span class="o">:</span> <span class="m">0.1</span><span class="p">,</span> <span class="n">Y</span><span class="o">:</span> <span class="m">0.2</span><span class="p">,</span> <span class="n">Z</span><span class="o">:</span> <span class="m">0.3</span><span class="p">}</span>
	
<span class="k">var</span> <span class="n">scaler</span> <span class="n">Scaler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="m">10.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Beside interfaces that have functions, go offers the empty interface as a method to hold a variable of any type. Any object can be assigned to the empty interface, including the scalar types. Here is an example:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// empty interface</span>
<span class="k">var</span> <span class="n">intf</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="s">"Hello World"</span>

<span class="c">// querying the empty interface for the underlying type</span>
<span class="k">if</span> <span class="n">s</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">intf</span><span class="o">.</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// i := intf(float32) would panic</span>
<span class="c">// need to test of OK</span>
<span class="k">if</span> <span class="n">i</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">intf</span><span class="o">.</span><span class="p">(</span><span class="kt">float32</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// a better way is to test with a type switch</span>
<span class="c">// interesting is that v is the value converted to the type, not the type</span>
<span class="k">switch</span> <span class="n">v</span> <span class="o">:=</span> <span class="n">intf</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="kt">string</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"It's a string!"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
	<span class="k">case</span> <span class="kt">int</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"It's an int!"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
	<span class="k">case</span> <span class="kt">float32</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"It's a float!"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When it comes to interfaces, golang offers a very elegant solution to encapsulation and type aggregation. It reminds me of power of <code class="language-plaintext highlighter-rouge">IUnknown::QueryInterface()</code> from <code class="language-plaintext highlighter-rouge">COM</code>, but embedded in the language itself. It relies on type assertions and embedded types.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="c">/*Beautiful method for embedding types and exposing interfaces in Golang. */</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"unsafe"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">Writer</span> <span class="k">interface</span><span class="p">{</span>
	<span class="n">Write</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Reader</span> <span class="k">interface</span><span class="p">{</span>
	<span class="n">Read</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ReaderWriter</span> <span class="k">struct</span><span class="p">{</span>
	<span class="n">Reader</span>
	<span class="n">Writer</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">rwImplType</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">str</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">rwImplType</span><span class="p">)</span> <span class="n">Read</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c">// same underlying pointer</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">rw</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">rw</span><span class="o">.</span><span class="n">str</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">rw</span><span class="o">*</span> <span class="n">rwImplType</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">msg</span> <span class="kt">string</span><span class="p">){</span>
	<span class="c">// same underlying pointer</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">rw</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rw</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="c">// Instatiante a concrete implementation</span>
	<span class="n">rwImpl</span> <span class="o">:=</span> <span class="n">rwImplType</span><span class="p">{</span><span class="n">str</span><span class="o">:</span> <span class="s">"Hello World"</span><span class="p">}</span>
	
	<span class="c">// expose it in an aggregate public interface which</span>
	<span class="c">// implements several interfaces</span>
	<span class="n">rwIntf</span> <span class="o">:=</span> <span class="n">ReaderWriter</span><span class="p">{</span>
		<span class="n">Reader</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">rwImpl</span><span class="p">,</span>
		<span class="n">Writer</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">rwImpl</span><span class="p">,</span> <span class="c">// can be another implementation</span>
	<span class="p">}</span>
	
	<span class="k">var</span> <span class="n">anon</span> <span class="k">interface</span><span class="p">{}</span> <span class="o">=</span> <span class="n">rwIntf</span>
	
	<span class="c">// QueryInterface()</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">anon</span><span class="o">.</span><span class="p">(</span><span class="n">Reader</span><span class="p">)</span>
	<span class="n">w</span> <span class="o">:=</span> <span class="n">anon</span><span class="o">.</span><span class="p">(</span><span class="n">Writer</span><span class="p">)</span>
	
	<span class="c">// works like a charm :)</span>
	<span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">Read</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Go playground link <a href="https://play.golang.org/p/lBDFao9Yo4G">here</a></p>

<p>Speaking of the <code class="language-plaintext highlighter-rouge">switch</code> construct, it is quite flexible:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// switch</span>
<span class="c">// with declaration and condition</span>
<span class="k">switch</span> <span class="n">os</span> <span class="o">:=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOOS</span><span class="p">;</span> <span class="n">os</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">"linux"</span><span class="o">:</span>
		<span class="k">fallthrough</span>
	<span class="k">case</span> <span class="s">"windows"</span><span class="p">,</span> <span class="s">"darwin"</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Running on %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">os</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Unknown"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// with no condition</span>
<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Weekday</span><span class="p">()</span><span class="o">.</span><span class="n">String</span><span class="p">()</span> <span class="o">==</span> <span class="s">"Thursday"</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Today is Thursday"</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Today is not Thursday"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="maps">Maps</h3>

<p>Maps can be initialized as literals or created dinamically with <code class="language-plaintext highlighter-rouge">make</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">// dynamic instantiation</span>
<span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Vertex</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
<span class="n">m</span><span class="p">[</span><span class="s">"Iasi"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">1.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">}</span>

<span class="c">// check for existence of an element</span>
<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">exists</span> <span class="o">:=</span> <span class="n">m</span><span class="p">[</span><span class="s">"Cluj"</span><span class="p">];</span> <span class="o">!</span><span class="n">exists</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Cluj does not exist in the map"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="s">"Iasi"</span><span class="p">]</span><span class="o">.</span><span class="n">Length</span><span class="p">())</span>

<span class="c">// literal instantiation</span>
<span class="n">m1</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Vertex</span><span class="p">{</span>
		<span class="s">"Iasi"</span><span class="o">:</span>      <span class="p">{</span><span class="m">1.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">},</span> <span class="c">// no need to specify Vertex</span>
		<span class="s">"Bucharest"</span><span class="o">:</span> <span class="p">{</span><span class="m">2.0</span><span class="p">,</span> <span class="m">2.0</span><span class="p">,</span> <span class="m">2.0</span><span class="p">},</span>
<span class="p">}</span>

<span class="c">// map can be increased</span>
<span class="n">m1</span><span class="p">[</span><span class="s">"Cluj"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vertex</span><span class="p">{</span><span class="m">3.0</span><span class="p">,</span> <span class="m">3.0</span><span class="p">,</span> <span class="m">3.0</span><span class="p">}</span>

<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

<span class="c">// remove the element from the map</span>
<span class="nb">delete</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="s">"Cluj"</span><span class="p">)</span>

<span class="c">// or also literal instantiation but with no elements</span>
<span class="n">counts</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</code></pre></div></div>

<h3 id="sample-programs">Sample Programs</h3>

<p>Fibonnaci - function returning a function</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"fmt"</span>

<span class="c">// fibonacci is a function that returns</span>
<span class="c">// a function that returns an int.</span>
<span class="k">func</span> <span class="n">fibonacci</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  
  <span class="c">// declaration - initialization</span>
	<span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span>

	<span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">:=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span>
		<span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="p">,</span> <span class="n">ret</span>
		<span class="k">return</span> <span class="n">ret</span>
	<span class="p">}</span>
	
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="n">fibonacci</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">f</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Error management and the Error interface:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">ErrNegativeSqrt</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">ErrNegativeSqrt</span><span class="p">)</span> <span class="n">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="m">0.0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"Negative sqrt %v"</span><span class="p">,</span> <span class="kt">float64</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">""</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Sqrt</span><span class="p">(</span><span class="n">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="m">0.0</span><span class="p">{</span>
		<span class="k">return</span> <span class="m">0.0</span><span class="p">,</span> <span class="n">ErrNegativeSqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
	<span class="p">}</span>
	
	<span class="n">z</span> <span class="o">:=</span> <span class="m">1.0</span>
	<span class="n">delta</span> <span class="o">:=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">x</span>
	
	<span class="k">for</span> <span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">1e-10</span><span class="p">{</span> 
		<span class="n">z</span> <span class="o">-=</span> <span class="n">delta</span> <span class="o">/</span> <span class="p">(</span><span class="m">2.0</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
		<span class="n">delta</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">x</span> 
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">v</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">Sqrt</span><span class="p">(</span><span class="o">-</span><span class="m">2</span><span class="p">);</span> <span class="n">err</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>	
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>	
	<span class="p">}</span>	
<span class="p">}</span>
</code></pre></div></div>

<p>Reader implementation. An in-memory stream obtained from a string can be created with <code class="language-plaintext highlighter-rouge">r := strings.NewReader("Hello, Reader!")</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"io"</span>
	<span class="s">"os"</span>
	<span class="s">"strings"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">rot13Reader</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="n">rot13Reader</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">){</span>
  
  <span class="c">// returns the number of elements read </span>
  <span class="c">// and an error if an error occured</span>
  <span class="c">// the error can be io.EOF which signifies the end of the stream</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
	
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="o">:</span> 
			<span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="m">13</span><span class="p">)</span> <span class="o">%</span> <span class="m">26</span> <span class="o">+</span> <span class="sc">'A'</span>
		<span class="k">case</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="o">:</span>
			<span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="m">13</span><span class="p">)</span> <span class="o">%</span> <span class="m">26</span> <span class="o">+</span> <span class="sc">'a'</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> 
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="n">strings</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="s">"Lbh penpxrq gur pbqr!"</span><span class="p">)</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">rot13Reader</span><span class="p">{</span><span class="n">s</span><span class="p">}</span>
	<span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="concurrency">Concurrency</h3>

<p>Concurrency in go is achieved through goroutines. Goroutines are language constructs which maps M virtual threads to N CPU threads. The runtime has its own scheduler. The preferred way of of sharing state is through channels, although shared memory is also possible thanks to the <code class="language-plaintext highlighter-rouge">sync</code> standard package. Let’s look at two programs below.</p>

<p>The first program compares two BSTs.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"golang.org/x/tour/tree"</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="c">// Walk DFSes the tree t sending all values</span>
<span class="c">// to the channel ch.</span>
<span class="k">func</span> <span class="n">Walk_</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">tree</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">){</span>

	<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">Left</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">{</span>
		<span class="n">Walk_</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Left</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c">// send the current value to the channel</span>
	<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">.</span><span class="n">Value</span>

	<span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">Right</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">Walk_</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Right</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Walk</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">tree</span><span class="o">.</span><span class="n">Tree</span><span class="p">,</span> <span class="n">ch</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">){</span>
  <span class="n">Walk_</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>

  <span class="c">// close the channel to signal the end of the tree</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> 
<span class="p">}</span>

<span class="c">// Same determines whether the trees</span>
<span class="c">// t1 and t2 contain the same values.</span>

<span class="k">func</span> <span class="n">Same</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">*</span><span class="n">tree</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>

  <span class="c">// make two channels</span>
	<span class="n">c1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="n">c2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>

  <span class="c">// launch the two walks in parallel</span>
	<span class="k">go</span> <span class="n">Walk</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">Walk</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>

  <span class="c">// Read one value at a time from each channel</span>
  <span class="c">// and compare them</span>
	<span class="k">for</span> <span class="n">ok1</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">:=</span> <span class="no">true</span><span class="p">,</span> <span class="no">true</span><span class="p">;</span> <span class="n">ok1</span> <span class="o">&amp;&amp;</span> <span class="n">ok2</span><span class="p">;</span>  <span class="p">{</span>
		<span class="k">var</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="kt">int</span>

    <span class="c">// when one channel is closed, its OK value is set to false</span>
		<span class="n">v1</span><span class="p">,</span> <span class="n">ok1</span> <span class="o">=</span> <span class="o">&lt;-</span> <span class="n">c1</span>
		<span class="n">v2</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">=</span> <span class="o">&lt;-</span> <span class="n">c2</span>

		<span class="k">if</span> <span class="n">ok1</span> <span class="o">!=</span> <span class="n">ok2</span> <span class="o">||</span> <span class="n">v1</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">Same</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="m">1</span><span class="p">),</span> <span class="n">tree</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Same tree"</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Not the same tree"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>Notes:</em></p>

<ul>
  <li>A channel cannot be closed twice</li>
  <li>A write from a closed channel results in a panic</li>
  <li>You can check on read if the channel is closed</li>
  <li>Channel operations are blocking. A channel can have a buffer, in which condition the operation becomes blocking only when the buffer is full</li>
  <li>A channel can be read with a <code class="language-plaintext highlighter-rouge">range</code> construct. The range finishes when the sender closes the channel</li>
</ul>

<p>The second program, also part of the golang tour, introduces <code class="language-plaintext highlighter-rouge">sync.WaitGroups</code> to allow waiting for goroutines to finish as well as sending return channels through input channels for safe reply. To allow for concurrent access, the <code class="language-plaintext highlighter-rouge">Cache</code> is implemented as a process (actor) which is accessible only through its input and output channels.</p>

<p>We are going to send a pair to our cache service, <code class="language-plaintext highlighter-rouge">&lt;string - key, return channel&gt;</code>. The return channel solves a concurrency issue: assuming that we have more concurrent readers waiting, we want to ensure we return the result to the reader that sent the message. Since in our case we use a non-buffered write channel, all writes are blocked until a new read is performed and, since the cache is a single threaded, it will not make a new read until the result is communicated, we could have used a single return channel for all the cache requests. However, if we make the write channel buffered, thus allowing for multiple writes, the returns will be mixed.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
<span class="p">)</span>

<span class="c">// the wait group is needed to allow all goroutines </span>
<span class="c">// to signal when they finish execution</span>
<span class="c">// and the main goroutine to wait for them</span>
<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>

<span class="k">type</span> <span class="n">Fetcher</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Fetch</span><span class="p">(</span><span class="n">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">body</span> <span class="kt">string</span><span class="p">,</span> <span class="n">urls</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
<span class="c">// message including the return channel</span>
<span class="k">type</span> <span class="n">CacheMsg</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">str</span> <span class="kt">string</span>
	<span class="n">out</span> <span class="k">chan</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Cache</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">in</span> <span class="k">chan</span> <span class="n">CacheMsg</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Cache</span><span class="p">)</span> <span class="n">Init</span><span class="p">(){</span>
	<span class="n">p</span><span class="o">.</span><span class="n">in</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">CacheMsg</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">p</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Cache</span><span class="p">)</span> <span class="n">Test</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  
  <span class="c">// create a new return channel for each service request</span>
	<span class="n">msg</span> <span class="o">:=</span> <span class="n">CacheMsg</span> <span class="p">{</span>
		<span class="n">str</span><span class="o">:</span> <span class="n">s</span><span class="p">,</span>
		<span class="n">out</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">),</span>
	<span class="p">}</span>
	
	<span class="n">p</span><span class="o">.</span><span class="n">in</span> <span class="o">&lt;-</span> <span class="n">msg</span>
	<span class="k">return</span> <span class="o">&lt;-</span> <span class="n">msg</span><span class="o">.</span><span class="n">out</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Cache</span><span class="p">)</span> <span class="n">cache</span><span class="p">(){</span>
  
  <span class="c">// our cache map</span>
	<span class="n">cache</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
  
  <span class="c">// read messages with range until the channel is closed</span>
	<span class="k">for</span> <span class="n">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">p</span><span class="o">.</span><span class="n">in</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">exists</span> <span class="o">:=</span> <span class="n">cache</span><span class="p">[</span><span class="n">msg</span><span class="o">.</span><span class="n">str</span><span class="p">];</span> <span class="n">exists</span> <span class="p">{</span>
			<span class="n">msg</span><span class="o">.</span><span class="n">out</span> <span class="o">&lt;-</span> <span class="no">true</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cache</span><span class="p">[</span><span class="n">msg</span><span class="o">.</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="no">true</span>
			<span class="n">msg</span><span class="o">.</span><span class="n">out</span> <span class="o">&lt;-</span> <span class="no">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">func</span> <span class="n">Crawl</span><span class="p">(</span><span class="n">url</span> <span class="kt">string</span><span class="p">,</span> <span class="n">depth</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fetcher</span> <span class="n">Fetcher</span><span class="p">,</span> <span class="n">cache</span> <span class="o">*</span><span class="n">Cache</span><span class="p">)</span> <span class="p">{</span>

  <span class="c">// ensure we call wg.Done() when the method exits</span>
  <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>

	<span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
  
  <span class="c">// the url is already in the cache</span>
	<span class="k">if</span> <span class="n">cache</span><span class="o">.</span><span class="n">Test</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	
	<span class="n">body</span><span class="p">,</span> <span class="n">urls</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">fetcher</span><span class="o">.</span><span class="n">Fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"found: %s %q</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
  
  <span class="c">// add N new goroutines to the WaitGroup</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">urls</span><span class="p">))</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">u</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">urls</span> <span class="p">{</span>

    <span class="c">// launch crawl goroutines in parallel</span>
		<span class="k">go</span> <span class="n">Crawl</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">depth</span><span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="n">fetcher</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	
	<span class="k">var</span> <span class="n">cache</span> <span class="n">Cache</span>
	<span class="n">cache</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>
	
	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="n">Crawl</span><span class="p">(</span><span class="s">"https://golang.org/"</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="n">fetcher</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">)</span>
  <span class="c">// wait for all goroutines to finish</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// fakeFetcher is Fetcher that returns canned results.</span>
<span class="k">type</span> <span class="n">fakeFetcher</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">fakeResult</span>

<span class="k">type</span> <span class="n">fakeResult</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">body</span> <span class="kt">string</span>
	<span class="n">urls</span> <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">fakeFetcher</span><span class="p">)</span> <span class="n">Fetch</span><span class="p">(</span><span class="n">url</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">res</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">f</span><span class="p">[</span><span class="n">url</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">urls</span><span class="p">,</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"not found: %s"</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// fetcher is a populated fakeFetcher.</span>
<span class="k">var</span> <span class="n">fetcher</span> <span class="o">=</span> <span class="n">fakeFetcher</span><span class="p">{</span>
	<span class="s">"https://golang.org/"</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">fakeResult</span><span class="p">{</span>
		<span class="s">"The Go Programming Language"</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
			<span class="s">"https://golang.org/pkg/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/cmd/"</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="s">"https://golang.org/pkg/"</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">fakeResult</span><span class="p">{</span>
		<span class="s">"Packages"</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
			<span class="s">"https://golang.org/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/cmd/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/pkg/fmt/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/pkg/os/"</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="s">"https://golang.org/pkg/fmt/"</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">fakeResult</span><span class="p">{</span>
		<span class="s">"Package fmt"</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
			<span class="s">"https://golang.org/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/pkg/"</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="s">"https://golang.org/pkg/os/"</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">fakeResult</span><span class="p">{</span>
		<span class="s">"Package os"</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
			<span class="s">"https://golang.org/"</span><span class="p">,</span>
			<span class="s">"https://golang.org/pkg/"</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The implementation above is more generic as it can be used as a pattern for other kinds of services. In our case, a faster solution would have been to use shared memory protected through a <code class="language-plaintext highlighter-rouge">sync.Mutex</code>, <code class="language-plaintext highlighter-rouge">sync.RWMutex</code> or through a <code class="language-plaintext highlighter-rouge">sync.Map</code>, a concurrent map.</p>

<p>One thing to note - altough all IO operations in go are blocking the current goroutine, the are implemented as asyncio behind the scenes, in a similar manner to which the <code class="language-plaintext highlighter-rouge">cache.Test()</code> method above is blocking.</p>

<h3 id="timers-and-select">Timers and select</h3>

<p>Select allows to listen to multiple channels and block until one of them has data available. Timers in golang are implemented as channels. Signaling to a goroutine to finish its job can be done also though a channel.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">seconds</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">minutes</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Minute</span><span class="p">)</span>

	<span class="n">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="n">wg</span> <span class="o">:=</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">{}</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">done</span><span class="o">:</span>
				<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
				<span class="k">return</span> <span class="c">// exit the routine</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">seconds</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Tick"</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">minutes</span><span class="o">.</span><span class="n">C</span><span class="o">:</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Tock"</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span> <span class="c">// immediately invoked goroutine</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Minute</span> <span class="o">*</span> <span class="m">3</span><span class="p">)</span>
	<span class="n">done</span> <span class="o">&lt;-</span> <span class="no">true</span>

	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Done."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>Go is a very beautiful and performant language. It is low level enough to feel like you have power you have in C and it compiles to native code for super fast startup times, performance and interoperability. It is elegant as it does not have unnecessary constructs yet, though its constructs, it encourages at the language level clean code and excellent concurrency.</p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
