<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++ Play - Green Threads in C++</title>
  <meta name="description" content="In this post I will write about green threads and provide a sample implementation in C++ - or, better say, in C++ mixed with assembly language. The code is h...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://alexandrugris.github.io/native/coding/2017/03/09/C++-Play-GreenThreads.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">        
      </span>

      <div class="trigger">

        <a class="page-link" href="https://alexandrugris.github.io">Home</a>

        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">C++ Play - Green Threads in C++</h1>
    <p class="post-meta"><time datetime="2017-03-09T15:15:16+01:00" itemprop="datePublished">Mar 9, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In this post I will write about <a href="https://en.wikipedia.org/wiki/Green_threads">green threads</a> and provide a sample implementation in C++ - or, better say, in C++ mixed with assembly language. The code is highly compiler-dependant (VC++17) and fragile, thus not production-ready. It makes assumptions about stack layout and data in registers and even something as simple as turning on optimizations will most likely crash it. But it was a fun programming exercise for a concept often implemented in asynchronous libraries or found in some programming language constructs. Interesting links: <a href="https://en.wikipedia.org/wiki/Fiber_%28computer_science%29">Fibers</a>, <a href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a>, <a href="https://en.wikipedia.org/wiki/Setcontext">Set Context</a>, <a href="https://en.wikipedia.org/wiki/Actor_model">Actors</a>, <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">Cooperative multitasking</a></p>

<h3 id="the-problem">The problem</h3>

<p>You have N CPUs and M threads, where M » N  - the case for actors, for instance. You know that these M threads will most likely interact with each other (either passing messages or synchronizing on some primitive). You might also have I/O and you want to keep the program flow simple and not pollute it with lots of callbacks - synchronous I/O code is clearly much simpler to read than async I/O, but also more heavy on the OS. These problems are suitable for considering a cooperative scheduling approach.</p>

<p><img src="/assets/green_threads_1.png" alt="vs_run" /></p>

<h3 id="the-api-and-the-test-scenario">The API and the test scenario</h3>

<p>For this demo I will only implement <code class="highlighter-rouge">wait-for</code> (waiting for a thread to finish) and <code class="highlighter-rouge">yield</code> (give control to the next thread). Any other operations would only make the code more complex to read but not add much clarity into the concepts. Here is my test bed:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">fn</span><span class="p">(</span><span class="n">thread_pool</span><span class="p">::</span><span class="n">thread_ctx</span> <span class="p">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="p">&gt;=</span> <span class="m">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Ended NO yields: "</span> <span class="p">&lt;&lt;</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">name</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">char</span> <span class="n">thread_name</span><span class="p">[</span><span class="m">80</span><span class="p">];</span>
	<span class="nf">sprintf_s</span><span class="p">(</span><span class="n">thread_name</span><span class="p">,</span> <span class="s">"Thread %d - %d"</span><span class="p">,</span> <span class="n">p1</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>
	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Starts: "</span> <span class="p">&lt;&lt;</span> <span class="n">thread_name</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">auto</span> <span class="n">child1</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">call_fn</span><span class="p">(</span><span class="m">100000</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">p1</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>

	<span class="nf">sprintf_s</span><span class="p">(</span><span class="n">thread_name</span><span class="p">,</span> <span class="s">"Secondary thread %d - %d"</span><span class="p">,</span> <span class="n">p1</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>
	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Starts: "</span> <span class="p">&lt;&lt;</span> <span class="n">thread_name</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="n">auto</span> <span class="n">child2</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">call_fn</span><span class="p">(</span><span class="m">100000</span><span class="p">,</span> <span class="n">thread_name</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">p1</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>

	<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="nf">decltype</span><span class="p">(</span><span class="n">child1</span><span class="p">)&gt;</span> <span class="n">children</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">7</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>

		<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="n">p1</span> <span class="p">&lt;&lt;</span> <span class="n">p2</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

		<span class="n">auto</span> <span class="n">p</span> <span class="p">=</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">call_fn</span><span class="p">(</span><span class="m">10000</span><span class="p">,</span> <span class="s">"Child of child"</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">p1</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">p2</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>

		<span class="n">children</span><span class="p">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">ctx</span><span class="p">-&gt;</span><span class="k">yield</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">wait_for</span><span class="p">(</span><span class="n">child1</span><span class="p">);</span>
	<span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">wait_for</span><span class="p">(</span><span class="n">child2</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="p">&amp;</span><span class="n">c</span> <span class="p">:</span> <span class="n">children</span><span class="p">)</span>
		<span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">wait_for</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Ended WITH yields: "</span> <span class="p">&lt;&lt;</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">name</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">p1</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">p2</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

	<span class="n">thread_pool</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">pool</span><span class="p">.</span><span class="nf">call_fn</span><span class="p">(</span><span class="m">100000</span><span class="p">,</span> <span class="s">"THREAD_0"</span> <span class="p">,</span><span class="n">fn</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>	
	<span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="highlighter-rouge">main</code> I simply call on the main thread, which I named “THREAD_0”, a procedure, <code class="highlighter-rouge">fn</code>, defined above. This is (and should be) a synchronous call. <code class="highlighter-rouge">fn</code> should wait for all spawned threads to be finished. Note: when I say “thread”, I mean a “green thread”. All my threads share the same OS thread. In this sample there is no OS multithreading involved. From the OS perspective the application is single threaded.</p>

<p>The <code class="highlighter-rouge">fn</code> function spawns recursively many other child-threads which are waited for at the end of the function. Context switching happens when control reaches the <code class="highlighter-rouge">ctx-&gt;yield()</code> call. <code class="highlighter-rouge">ctx</code> is our current thread (an instance of the <code class="highlighter-rouge">thread_context</code> class). If control does not reach a <code class="highlighter-rouge">ctx-&gt;yield()</code>, the function is simply executed on the stack of the caller, synchronously, like a normal function. When control reaches <code class="highlighter-rouge">ctx-&gt;yield()</code> the function will be put on hold and the rest of the threads will be executed. On the spawning thread, control is given back to the caller, asynchronously, not waiting for the new thread to finish. The result is a <code class="highlighter-rouge">thread_ctx</code> object which can be queried for work completion or waited for. When a thread is spawned, parameters can be sent to it like to any other function, on the stack - the implementation is based on a variadic template. In our case I send two <code class="highlighter-rouge">ints</code>.</p>

<h3 id="api-description">API description:</h3>

<p><code class="highlighter-rouge">template&lt;class fn, typename... T&gt; void thread_pool::call_fn(unsigned int stack_size, const char* name, fn* f, T... params)</code> - creates the parent thread. It is the way to initialize the threading library because for the parent thread return information should be stored in the main process stack. The function should wait for all its children to finish before exiting.</p>

<p><code class="highlighter-rouge">template&lt;class fn, typename... T&gt; shared_ptr&lt;thread_ctx&gt; thread_pool::thread_ctx::call_fn(unsigned int stack_size, const char* name ,fn* f, T... params)</code> - spawns a new child thread.</p>

<p><code class="highlighter-rouge">void thread_pool::thread_ctx::wait_for(shared_ptr&lt;thread_ctx&gt;&amp; other)</code> - waits for a child.</p>

<p><code class="highlighter-rouge">void thread_pool::thread_ctx::yield()</code> - gives control to the next thread waiting for execution in a round-robin fashion.</p>

<h3 id="implementation">Implementation</h3>

<p>Here is the full listing:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _DEBUG
</span>
<span class="cp">#pragma optimize ("", off)
</span>
<span class="k">class</span> <span class="nc">thread_pool</span> <span class="p">{</span>

<span class="k">private</span><span class="p">:</span>
	<span class="n">unsigned</span> <span class="kt">int</span> <span class="n">current_thread</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>	

<span class="k">public</span><span class="p">:</span>

	<span class="k">struct</span> <span class="nc">thread_ctx</span> <span class="p">{</span>

	<span class="k">private</span><span class="p">:</span>
		<span class="kt">char</span><span class="p">*</span> <span class="n">thread_name</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>

	<span class="k">private</span><span class="p">:</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">stack</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">stack_ptr</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">continuation_location</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>

		<span class="n">thread_pool</span><span class="p">*</span> <span class="n">th_p</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="kt">bool</span>	<span class="n">b_finished</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
		
		<span class="c1">// for when we have an out of order return from the function.</span>
		<span class="kt">bool</span>	<span class="n">b_yielded</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 

<span class="err">#</span><span class="n">ifdef</span> <span class="n">_DEBUG</span>
		<span class="kt">int</span> <span class="n">stack_size</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="cp">#endif
</span>
	<span class="k">public</span><span class="p">:</span> 
		<span class="n">friend</span> <span class="k">class</span> <span class="nc">thread_pool</span><span class="p">;</span>
		<span class="nf">thread_ctx</span><span class="p">(</span><span class="n">thread_pool</span><span class="p">*</span> <span class="n">tp</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_stack_size</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">:</span> <span class="nf">th_p</span><span class="p">(</span><span class="n">tp</span><span class="p">){</span>

<span class="err">#</span><span class="n">ifdef</span> <span class="n">_DEBUG</span>
			<span class="n">stack_size</span> <span class="p">=</span> <span class="n">_stack_size</span><span class="p">;</span>
<span class="cp">#endif
</span>			<span class="n">stack</span> <span class="p">=</span> <span class="k">new</span> <span class="n">unsigned</span> <span class="kt">char</span><span class="p">[</span><span class="n">_stack_size</span><span class="p">];</span>
			<span class="n">stack_ptr</span> <span class="p">=</span> <span class="n">stack</span> <span class="p">+</span> <span class="n">_stack_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="p">~</span><span class="nf">thread_ctx</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">delete</span><span class="p">[]</span> <span class="n">stack</span><span class="p">;</span>
			<span class="c1">// cout &lt;&lt; "Deleted: " &lt;&lt; thread_name &lt;&lt; endl;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">thread_name</span><span class="p">)</span>
				<span class="nf">free</span><span class="p">(</span><span class="n">thread_name</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">thread_pool</span><span class="p">*</span> <span class="nf">get_thread_pool</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">th_p</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="nf">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">thread_name</span><span class="p">;</span> <span class="p">}</span>

		<span class="kt">bool</span> <span class="nf">finished</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b_finished</span><span class="p">;</span> <span class="p">}</span>

		<span class="k">void</span> <span class="nf">wait_for</span><span class="p">(</span><span class="n">shared_ptr</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(!</span><span class="n">other</span><span class="p">-&gt;</span><span class="n">b_finished</span><span class="p">)</span>
				<span class="k">yield</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">void</span> <span class="k">yield</span><span class="p">()</span> <span class="p">{</span>

			<span class="kt">int</span> <span class="n">stk_tst</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
			<span class="n">b_yielded</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

<span class="err">#</span><span class="n">ifdef</span> <span class="n">_DEBUG</span>
			<span class="c1">// test we are on our stack</span>
			<span class="nf">assert</span><span class="p">(</span> <span class="kt">int</span><span class="p">(&amp;</span><span class="n">stk_tst</span><span class="p">)</span> <span class="p">&gt;=</span> <span class="kt">int</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="kt">int</span><span class="p">(&amp;</span><span class="n">stk_tst</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">stack_size</span> <span class="p">+</span> <span class="kt">int</span><span class="p">(</span><span class="n">stack</span><span class="p">));</span>
<span class="cp">#endif
</span>			
			<span class="n">unsigned</span> <span class="kt">char</span><span class="p">**</span> <span class="n">loc_ptr</span>		<span class="p">=</span> <span class="p">&amp;</span><span class="n">continuation_location</span><span class="p">;</span>
			<span class="n">auto</span> <span class="n">next</span>			<span class="p">=</span> <span class="n">th_p</span><span class="p">-&gt;</span><span class="nf">next</span><span class="p">();</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">-&gt;</span><span class="n">b_finished</span> <span class="p">||</span> 
				<span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="k">get</span><span class="p">()</span> <span class="p">!=</span> <span class="k">this</span> <span class="p">&amp;&amp;</span> <span class="n">next</span><span class="p">-&gt;</span><span class="n">continuation_location</span> <span class="p">==</span> <span class="n">nullptr</span><span class="p">))</span>
				<span class="n">next</span> <span class="p">=</span> <span class="n">th_p</span><span class="p">-&gt;</span><span class="nf">next</span><span class="p">();</span>

			<span class="n">auto</span> <span class="n">next_ptr</span> <span class="p">=</span> <span class="n">next</span><span class="p">.</span><span class="k">get</span><span class="p">();</span>

			<span class="c1">// cout &lt;&lt; "Yield: From " &lt;&lt; this-&gt;thread_name &lt;&lt; " To " </span>
			<span class="c1">// &lt;&lt; next_ptr-&gt;thread_name &lt;&lt; endl;</span>

			<span class="c1">// save the jump location for this thread</span>
			<span class="n">__asm</span> <span class="p">{</span>				
				<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">offset</span> <span class="n">continuation_code_ptr</span><span class="p">;</span>
				<span class="n">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">loc_ptr</span><span class="p">;</span>
				<span class="n">mov</span> <span class="p">[</span><span class="n">ebx</span><span class="p">],</span> <span class="n">eax</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">// save the current stack_ptr to restore it</span>
			<span class="n">__asm</span><span class="p">{</span>
				<span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="k">this</span><span class="p">;</span>
				<span class="n">push</span> <span class="n">stk_tst</span><span class="p">;</span>
				<span class="n">push</span> <span class="n">ebp</span><span class="p">;</span>
				<span class="n">mov</span> <span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">stack_ptr</span><span class="p">],</span> <span class="n">esp</span><span class="p">;</span>
			<span class="p">}</span>			
			
			<span class="c1">// do the jump to to next location,</span>
			<span class="n">__asm</span> <span class="p">{</span>
				<span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">next_ptr</span><span class="p">;</span>
				<span class="n">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">continuation_location</span><span class="p">];</span> <span class="c1">// next is in ecx</span>
				<span class="n">mov</span> <span class="n">esp</span><span class="p">,</span> <span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">stack_ptr</span><span class="p">];</span>
				<span class="n">jmp</span> <span class="n">ebx</span><span class="p">;</span>			
			<span class="p">}</span>

			<span class="nf">assert</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="c1">// should never get here</span>
			
			<span class="c1">// jmp location:</span>
			<span class="n">__asm</span>
			<span class="p">{</span>
			<span class="n">continuation_code_ptr</span><span class="p">:</span>
				<span class="n">pop</span> <span class="n">ebp</span><span class="p">;</span>
				<span class="n">pop</span> <span class="n">stk_tst</span><span class="p">;</span> <span class="c1">// should be 0;</span>
			<span class="p">}</span>

			<span class="nf">assert</span><span class="p">(</span><span class="n">stk_tst</span> <span class="p">==</span> <span class="m">0</span><span class="p">);</span>			
		<span class="p">}</span>

		<span class="n">template</span><span class="p">&lt;</span><span class="k">class</span> <span class="nc">fn</span><span class="p">,</span> <span class="n">typename</span><span class="p">...</span> <span class="n">T</span><span class="p">&gt;</span> 
		<span class="n">shared_ptr</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;</span> 
		<span class="nf">call_fn</span><span class="p">(</span><span class="n">unsigned</span> <span class="kt">int</span> <span class="n">stack_size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">name</span> <span class="p">,</span><span class="n">fn</span><span class="p">*</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span><span class="p">...</span> <span class="k">params</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">auto</span> <span class="n">ctx</span> <span class="p">=</span> <span class="n">make_shared</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;(</span><span class="n">th_p</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> 
				<span class="n">ctx</span><span class="p">-&gt;</span><span class="n">thread_name</span> <span class="p">=</span> <span class="nf">_strdup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

			<span class="n">th_p</span><span class="p">-&gt;</span><span class="n">threads</span><span class="p">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
			<span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">assign_fn</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="k">params</span><span class="p">...);</span>
			<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">private</span><span class="p">:</span>

		<span class="n">template</span><span class="p">&lt;</span><span class="k">class</span> <span class="nc">fn</span><span class="p">,</span> <span class="n">typename</span><span class="p">...</span> <span class="n">T</span><span class="p">&gt;</span> 
		<span class="k">void</span> <span class="nf">assign_fn</span><span class="p">(</span><span class="n">thread_ctx</span><span class="p">*</span> <span class="n">parent_thread</span><span class="p">,</span> <span class="n">fn</span><span class="p">*</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span><span class="p">...</span> <span class="k">params</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">stk_tst</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

			<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">stk</span> <span class="p">=</span> <span class="n">stack_ptr</span><span class="p">;</span>	

			<span class="k">if</span> <span class="p">(</span><span class="n">parent_thread</span> <span class="p">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// we are on root of threads</span>
				<span class="c1">// setup start of new thread</span>
				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">esp</span><span class="p">;</span> <span class="c1">// save old stack on new stack</span>
					<span class="n">mov</span> <span class="n">esp</span><span class="p">,</span> <span class="n">stk</span><span class="p">;</span>
					<span class="n">push</span> <span class="n">eax</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="nf">f</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">params</span><span class="p">...);</span>

				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">pop</span> <span class="n">esp</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">b_finished</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
				<span class="n">th_p</span><span class="p">-&gt;</span><span class="k">remove</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">unsigned</span> <span class="kt">char</span><span class="p">**</span> <span class="n">loc_ptr</span>		<span class="p">=</span> <span class="p">&amp;</span><span class="n">parent_thread</span><span class="p">-&gt;</span><span class="n">continuation_location</span><span class="p">;</span>
				<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span>	<span class="n">stck_ptr</span>	<span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
				
				<span class="c1">// save the jump location </span>
				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">offset</span> <span class="n">continuation_code_ptr</span><span class="p">;</span>
					<span class="n">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">loc_ptr</span><span class="p">;</span>
					<span class="n">mov</span><span class="p">[</span><span class="n">ebx</span><span class="p">],</span> <span class="n">eax</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="c1">// save the current stack_ptr to restore it (we are on parent stack)</span>
				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">push</span> <span class="n">stk_tst</span><span class="p">;</span>
					<span class="n">push</span> <span class="n">ebp</span><span class="p">;</span>
					<span class="n">mov</span><span class="p">[</span><span class="n">stck_ptr</span><span class="p">],</span> <span class="n">esp</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">parent_thread</span><span class="p">-&gt;</span><span class="n">stack_ptr</span> <span class="p">=</span> <span class="n">stck_ptr</span><span class="p">;</span>

				<span class="c1">// switch to the new thread stack</span>
				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">mov</span> <span class="n">esp</span><span class="p">,</span> <span class="n">stk</span><span class="p">;</span>
					<span class="n">push</span> <span class="n">stck_ptr</span><span class="p">;</span> <span class="c1">// these still work because we have not changed ebp</span>
					<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="k">this</span><span class="p">;</span>
					<span class="n">push</span> <span class="n">eax</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="nf">f</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">params</span><span class="p">...);</span>

				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">pop</span> <span class="n">ecx</span><span class="p">;</span> <span class="c1">// this is in ecx</span>
					<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">b_yielded</span><span class="p">];</span>
					<span class="n">and</span> <span class="n">al</span><span class="p">,</span> <span class="m">1</span>
					<span class="n">jnz</span> <span class="n">function_already_returned_once</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="c1">// switch back to parent stack</span>
				<span class="c1">// restore this</span>
				<span class="n">__asm</span> <span class="p">{</span>
					<span class="n">pop</span> <span class="n">eax</span><span class="p">;</span> <span class="c1">// stk_ptr</span>
					<span class="n">mov</span> <span class="n">esp</span><span class="p">,</span> <span class="n">eax</span><span class="p">;</span> <span class="c1">// stk_ptr</span>
					<span class="n">pop</span> <span class="n">ebp</span><span class="p">;</span>					
					<span class="n">pop</span> <span class="n">stk_tst</span><span class="p">;</span> <span class="c1">// here we already have the values</span>
				<span class="p">}</span>

				<span class="nf">assert</span><span class="p">(</span><span class="n">stk_tst</span> <span class="p">==</span> <span class="m">0</span><span class="p">);</span>

				<span class="n">b_finished</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
				<span class="n">th_p</span><span class="p">-&gt;</span><span class="k">remove</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

				<span class="k">return</span><span class="p">;</span>

				<span class="n">__asm</span> <span class="p">{</span>
				<span class="n">function_already_returned_once</span><span class="p">:</span>

					<span class="c1">// this is in ecx</span>
					<span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">b_finished</span><span class="p">];</span>
					<span class="n">or</span> <span class="n">al</span><span class="p">,</span> <span class="m">1</span><span class="p">;</span>
					<span class="n">mov</span><span class="p">[</span><span class="n">ecx</span> <span class="p">+</span> <span class="n">b_finished</span><span class="p">],</span> <span class="n">eax</span><span class="p">;</span> <span class="c1">// set the b_finished flag to true</span>

					<span class="n">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">;</span> <span class="c1">// save this temporary</span>
					<span class="n">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="p">[</span><span class="n">ebx</span> <span class="p">+</span> <span class="n">th_p</span><span class="p">];</span>

					<span class="n">push</span> <span class="n">ebx</span><span class="p">;</span> <span class="c1">// once for saving, once for remove call</span>
					<span class="n">push</span> <span class="n">ebx</span><span class="p">;</span>
					<span class="n">call</span> <span class="k">remove</span><span class="p">;</span>

					<span class="n">pop</span> <span class="n">ecx</span><span class="p">;</span>
					<span class="n">call</span> <span class="k">yield</span>

					<span class="c1">// TODO: set the b_finished flag and then remove the thread</span>
					<span class="c1">// do yield</span>
				<span class="p">}</span>

				<span class="nf">assert</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="c1">// should never get here.</span>

				<span class="n">__asm</span>
				<span class="p">{</span>
				<span class="n">continuation_code_ptr</span><span class="p">:</span> <span class="c1">// only for jmp code from another place</span>
					<span class="n">pop</span> <span class="n">ebp</span><span class="p">;</span>
					<span class="n">pop</span> <span class="n">stk_tst</span><span class="p">;</span> <span class="c1">// should be 0;</span>
				<span class="p">}</span>

				<span class="nf">assert</span><span class="p">(</span><span class="n">stk_tst</span> <span class="p">==</span> <span class="m">0</span><span class="p">);</span>
				<span class="c1">// cout &lt;&lt; "Async return for " &lt;&lt; this-&gt;thread_name &lt;&lt; endl;</span>
			<span class="p">}</span>

		<span class="p">}</span>			
	<span class="p">};</span>

<span class="k">private</span><span class="p">:</span>
	<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">shared_ptr</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;&gt;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="p">:</span>

	<span class="n">shared_ptr</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span> <span class="n">unsigned</span> <span class="n">th</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">th</span> <span class="p">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">th</span> <span class="p">++){</span>
			<span class="n">auto</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">threads</span><span class="p">[(++</span><span class="n">current_thread</span><span class="p">)</span> <span class="p">%</span> <span class="n">threads</span><span class="p">.</span><span class="nf">size</span><span class="p">()];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="p">!=</span> <span class="n">nullptr</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> 

		<span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">void</span> <span class="k">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">thread_ctx</span><span class="p">*</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span> <span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="p">++)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="k">get</span><span class="p">()</span> <span class="p">==</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">threads</span><span class="p">[</span><span class="n">threads</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
				<span class="n">threads</span><span class="p">.</span><span class="nf">pop_back</span><span class="p">();</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="nf">assert</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="c1">// not found</span>
	<span class="p">}</span>

	<span class="p">~</span><span class="nf">thread_pool</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
			<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>			
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">template</span><span class="p">&lt;</span><span class="k">class</span> <span class="nc">fn</span><span class="p">,</span> <span class="n">typename</span><span class="p">...</span> <span class="n">T</span><span class="p">&gt;</span> 
	<span class="k">void</span> <span class="nf">call_fn</span><span class="p">(</span><span class="n">unsigned</span> <span class="kt">int</span> <span class="n">stack_size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">*</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span><span class="p">...</span> <span class="k">params</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">auto</span> <span class="n">ctx</span> <span class="p">=</span> <span class="n">make_shared</span><span class="p">&lt;</span><span class="n">thread_ctx</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="n">ctx</span><span class="p">-&gt;</span><span class="n">thread_name</span> <span class="p">=</span> <span class="nf">_strdup</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

		<span class="n">threads</span><span class="p">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">ctx</span><span class="p">-&gt;</span><span class="nf">assign_fn</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="k">params</span><span class="p">...);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="explanations">Explanations:</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">thread_ctx</span> <span class="p">{</span>

	<span class="k">private</span><span class="p">:</span>
		<span class="kt">char</span><span class="p">*</span> <span class="n">thread_name</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>

	<span class="k">private</span><span class="p">:</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">stack</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">stack_ptr</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="kt">char</span><span class="p">*</span> <span class="n">continuation_location</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>

		<span class="n">thread_pool</span><span class="p">*</span> <span class="n">th_p</span> <span class="p">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="kt">bool</span>	<span class="n">b_finished</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
		<span class="c1">// for when we have an out of order return from the function.</span>
		<span class="kt">bool</span>	<span class="n">b_yielded</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> 
		
		<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">thread_ctx</code> - our thread.</li>
  <li><code class="highlighter-rouge">thread_name</code> - a private variable used for debug - helps identifying our thread.</li>
  <li><code class="highlighter-rouge">stack</code> - the <code class="highlighter-rouge">new</code>-allocated stack for our thread.</li>
  <li><code class="highlighter-rouge">stack_ptr</code> - stack pointer (esp). When a context switch is performed, <code class="highlighter-rouge">esp</code> is saved / restored to / from this variable.</li>
  <li><code class="highlighter-rouge">continuation_location</code> - pointer to the code location from which the thread was interrupted. It is saved and jumped to on context switch.</li>
  <li><code class="highlighter-rouge">thread_pool</code> - the parent thread, pool,</li>
  <li><code class="highlighter-rouge">b_finished</code> set if the thread has finished its work.</li>
  <li><code class="highlighter-rouge">b_yielded</code> an internal status set to true if the thread was ever interrupted. This is critical because, if the thread has been interrupted, the invocation will return asynchronously to the parent through an out-of-order return (<code class="highlighter-rouge">void assign_fn(thread_ctx* parent_thread, fn* f, T... params)</code>). The function will then continue, without another return to the caller. When it finishes, it just forwards control to the next waiting thread (a final call to <code class="highlighter-rouge">yield()</code>) and sets the <code class="highlighter-rouge">b_finished</code> flag.</li>
</ul>

<h3 id="some-compiler-specific-assumptions">Some compiler specific assumptions:</h3>

<ul>
  <li><code class="highlighter-rouge">ebp</code> is the root of the function stack.<a href="https://msdn.microsoft.com/en-us/library/2kxx5t2c.aspx"><code class="highlighter-rouge">/Oy</code> will crash our code</a>. This restriction could be removed through some extra push / pops.</li>
  <li><code class="highlighter-rouge">ecx</code> stores the <code class="highlighter-rouge">this</code> pointer (<code class="highlighter-rouge">thiscall</code> convention assumed). To access any members from <code class="highlighter-rouge">this</code> we do <code class="highlighter-rouge">mov ..., [ecx + var_name]</code></li>
  <li>inline asm assumes VC++ on 32 bits.</li>
</ul>

<p>Any optimizations that somehow assume the threads continue without interruptions will crash our code.</p>

<h3 id="comments">Comments</h3>

<ul>
  <li>I wrote this code for my own fun, with no other intention except getting it to work.</li>
  <li>Assembly language is extremely powerful and suited for such hacks. Optimizations are usually better left off to the compiler, but doing magic and jumping between functions? Well, there are C APIs already battletested for this, but it is fun to play around and provide a possible implementation for how these APIs work behind the scenes.</li>
  <li>Debugging jumps between functions is relatively hard as there is little information availabe. I coded incrementally, getting each line of code working, one by one.</li>
</ul>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
