<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++ Play - my own short guide to C++11/14</title>
  <meta name="description" content="C++ has evolved dramatically in the past years. It is virtually a new language, a huge improvement over the C++ I used to practice in the 2000s. Much more ex...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/native/coding/2017/01/28/C++-Play.html">
  <link rel="alternate" type="application/rss+xml" title="From The Trenches - The Code" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">

    <div class="site-nav"><a class="site-title" href="/">From The Trenches - The Code</a> </div>

    <nav class="site-nav">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </span>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/sm/">Social Media</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">C++ Play - my own short guide to C++11/14</h1>
    <p class="post-meta"><time datetime="2017-01-28T16:15:16+02:00" itemprop="datePublished">Jan 28, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>C++ has evolved dramatically in the past years. It is virtually a new language, a huge improvement over the C++ I used to practice in the 2000s.
Much more expressive templates, richer libraries, more emphasis on compile-time safety and performance improvements. Far from the C with classes in the early 2000s and far from the convoluted template constructs which appeared later to
improve compile-time issue detection and type safety. To refresh my memory and also get up to speed with the new trends, I have spent a couple of hours digging through the docs, doing some tutorials. Here are my notes.</p>

<h2 id="improvements-to-classes---inline-initializers-for-class-members">Improvements to classes - inline initializers for class members:</h2>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Test</span><span class="p">{</span>

	<span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="c1">// new in C++
</span>	<span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

	<span class="n">std</span><span class="p">::</span><span class="kt">string</span> <span class="n">test_str</span> <span class="p">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="smart-pointers-in-the-standard-library">Smart pointers in the standard library</h2>

<p>In the 2000s you really had three choices for memory management in the C++ world:</p>
<ul>
  <li>Manual (new / delete) with clear rules for owership in the “style-guide” of the project.</li>
  <li>The Boost library’s <code class="highlighter-rouge">shared_ptr</code> and <code class="highlighter-rouge">weak_ptr</code> for shared ownership or <code class="highlighter-rouge">std::auto_ptr</code>, the only smart pointer from the STD library, now deprecated.</li>
  <li>Custom-built smart pointers, autolists or any other custom constructs.</li>
</ul>

<p>Now smart pointers are included in the standard library and they are the preferred way of writing C++ code.</p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="n">include</span> <span class="p">&lt;</span><span class="n">memory</span><span class="p">&gt;</span>

<span class="c1">// ...
</span>
<span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="k">public</span><span class="p">:</span>
	<span class="nf">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="kt">string</span><span class="p">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>

<span class="p">}</span>

<span class="k">void</span> <span class="nf">test_shared_ptr</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// the recommended way to initialize a smart pointer because the ref-counter is
</span>	<span class="c1">// allocated in the same call with the memory for Test
</span>	<span class="c1">// =&gt; less memory fragmentation and better locality
</span>	<span class="n">shared_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="n">pTest</span> <span class="p">=</span> <span class="n">make_shared</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;(</span><span class="m">10</span><span class="p">,</span> <span class="m">10</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>
	<span class="n">weak_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="n">pwTest</span> <span class="p">=</span> <span class="n">pTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Another smart pointer construct is the <code class="highlighter-rouge">unique_ptr&lt; &gt;</code>, which replaces the now deprecated <code class="highlighter-rouge">auto_ptr</code> .
I think it is worth considering using it whenever possible instead of <code class="highlighter-rouge">boost::shared_ptr&lt;&gt;</code> and <code class="highlighter-rouge">boost::weak_ptr&lt;&gt;</code>.
I think it sends a stronger signal about ownership intent when used in new code.</p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="n">unique_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="nf">source_unique_ptr</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">make_unique</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="c1">// t is received by value. In this case, this function
// can only be called using std::move  on the pointer
</span><span class="k">void</span> <span class="nf">test_sink</span><span class="p">(</span><span class="n">unique_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="n">t</span><span class="p">-&gt;</span><span class="n">x</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">test_func_ref_unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">t</span> <span class="p">=</span> <span class="n">make_unique</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;();</span> <span class="c1">// destructor will be called here
</span>							 <span class="c1">// for the object sent by parameter
</span>	<span class="n">t</span><span class="p">-&gt;</span><span class="n">x</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">test_smart_pointers</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">auto</span> <span class="n">pt</span> <span class="p">=</span> <span class="nf">source_unique_ptr</span><span class="p">();</span>
	<span class="nf">test_func_ref_unique_ptr</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
	<span class="nf">test_sink</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="n">pt</span><span class="p">));</span> <span class="c1">// pt is now empty!
</span><span class="p">}</span>
</code></pre>
</div>

<p><em>Note:</em> <code class="highlighter-rouge">unique_ptr&lt;&gt;</code> cannot be sent by value - it will result in a compilation error. 
If the receiving function accepts the <code class="highlighter-rouge">unique_ptr&lt;&gt;</code> by value as parameter,
it can only be passed using the <code class="highlighter-rouge">std::move</code> function, which will nullify the pointer in the calling function. 
This is called the <em>sink pattern</em> and it is exemplified in the <code class="highlighter-rouge">test_sync</code> function above. 
The copy constructor for <code class="highlighter-rouge">unique_ptr&lt;&gt;</code> is explicitly deleted (later on this).</p>

<h2 id="improvements-to-collections">Improvements to collections</h2>

<p>C++11 brings us unordered associative containers, a fixed size array class and a singly-linked list (std::forwad_list): <a href="http://www.cplusplus.com/reference/stl/">http://www.cplusplus.com/reference/stl/</a>.</p>

<p>Because of the new language features (move semantics, std::initializer_list and variadic templates), collections have become much more useful and expressive 
For instance, now you can actually consider storing a full instance in a collection instead of just a pointer,
without worrying about endless copies and reallocations. This improves data locality and cache friendliness (provided that you have the appropriate move operations in place). 
For instance, old pattern in which we push pointers to <code class="highlighter-rouge">std::vector&lt;FullType*&gt;</code> is now similar in iteration speed with <code class="highlighter-rouge">std::lists&lt;FullType&gt;::emplace_back</code>. See below.</p>

<p>Here are some small examples:</p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="k">void</span> <span class="nf">test_collections</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">vector</span><span class="p">&lt;</span><span class="n">unique_ptr</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;&gt;</span> <span class="n">v_Test</span><span class="p">;</span>

	<span class="c1">// uses move semantics to fully change the ownership of the pointer to the collection.
</span>	<span class="c1">// provided that we had a full type with move constructor / move assignment,
</span>	<span class="c1">// on vector reallocation only the move operations would have been called.
</span>	<span class="n">v_Test</span><span class="p">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;());</span> 

	<span class="c1">// initializer list for vector and list
</span>	<span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">v_Int</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">};</span>

	<span class="n">list</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="n">tst</span> <span class="p">=</span> <span class="p">{</span>
		<span class="nf">Test</span><span class="p">()</span>
	<span class="p">};</span>

	<span class="c1">// new member function, based on variadic templates argument. 
</span>	<span class="c1">// No copy constructor, no move. 
</span>	<span class="c1">// Just construct the object at the end of the collection, invoking the right parameters
</span>	<span class="c1">// Better locality as the two pointers to back and forward from the list are stored next to the 
</span>	<span class="c1">// allocated memory for the Test object in this case.
</span>	<span class="n">tst</span><span class="p">.</span><span class="nf">emplace_back</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="s">"Test test test"</span><span class="p">);</span> 
<span class="p">}</span>

<span class="k">void</span> <span class="nf">test_collections_priority_queue</span><span class="p">()</span> <span class="p">{</span>

	<span class="c1">// deque does not do copies on increase; a little bit slower random access though
</span>	<span class="n">priority_queue</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">,</span> <span class="n">deque</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;</span> <span class="p">&gt;</span> <span class="n">tst</span><span class="p">;</span> 

	<span class="n">tst</span><span class="p">.</span><span class="nf">emplace</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span>
	<span class="n">tst</span><span class="p">.</span><span class="nf">emplace</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"B"</span><span class="p">);</span>
	<span class="n">tst</span><span class="p">.</span><span class="nf">emplace</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"C"</span><span class="p">);</span>

	<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Popping out elements..."</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(!</span><span class="n">tst</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="n">Test</span><span class="p">&amp;</span> <span class="n">t</span> <span class="p">=</span> <span class="n">tst</span><span class="p">.</span><span class="nf">top</span><span class="p">();</span>
		<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">str</span><span class="p">.</span><span class="nf">c_str</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="n">tst</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="lambdas">Lambdas</h3>

<p>I think it is pretty obvious why lambdas were introduced. Before lamdas, you were bind either to pointer to functions or to functor objects, 
which were implemended “far” from the point of interest. This made the std-algorithms harder to use, due to code verbosity and scrolling back and forth in the source code. 
All in all, lambdas are mostly syntactic sugar, but a very useful one.</p>

<p><em>Returning a lambda from a function and storing a lambda in a variable</em></p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="p">::</span><span class="n">function</span><span class="p">&lt;</span><span class="kt">double</span><span class="p">()&gt;</span> <span class="nf">getPIFunction</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">static</span> <span class="kt">double</span> <span class="n">PI</span> <span class="p">=</span> <span class="m">3.1415</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">[]()</span> <span class="p">{</span> <span class="c1">// because PI is declared as static, it does not need to be captured explicitly;
</span>		<span class="k">return</span> <span class="n">PI</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="c1">//....
</span>
<span class="n">auto</span> <span class="n">PI_func</span> <span class="p">=</span> <span class="nf">getPIFunction</span><span class="p">();</span>
<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="nf">typeid</span><span class="p">(</span><span class="n">PI_func</span><span class="p">).</span><span class="nf">name</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="s">": "</span> <span class="p">&lt;&lt;</span> <span class="nf">PI_func</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="c1">// output: class std::function&lt;double __cdecl(void)&gt;: 3.1415
</span></code></pre>
</div>

<p><em>Using lambdas in std::algorithms - passing them as arguments</em></p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="p">};</span>

<span class="nf">for_each</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="k">value</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">vector</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">cubes</span><span class="p">;</span>

<span class="c1">// back_inserter - very useful function
</span><span class="nf">transform</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span> <span class="nf">back_inserter</span><span class="p">(</span><span class="n">cubes</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> 
	<span class="k">return</span> <span class="n">n</span> <span class="p">*</span> <span class="n">n</span> <span class="p">*</span> <span class="n">n</span><span class="p">;</span>
<span class="p">});</span>

<span class="nf">for_each</span><span class="p">(</span><span class="n">cubes</span><span class="p">.</span><span class="nf">begin</span><span class="p">(),</span> <span class="n">cubes</span><span class="p">.</span><span class="nf">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span>  <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="k">value</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div>

<p><em>Improvements to lambdas starting with C++14</em></p>

<p>These include type deduction for lambda parameters - no need to send them explicitly, <code class="highlighter-rouge">auto</code> is enough and also 
initialization for capture parameters - useful when, for instance, you want to <code class="highlighter-rouge">move</code> an object when captured to lambda instead of just simply copy it by value, or apply any type of other transformation.</p>

<p>The code below uses another cool feature from C++ 11, the vadiadic templates. The template <code class="highlighter-rouge">invoke</code> simply invokes the functor it receives with the list of parameters it receives, 
all in a typesafe matter. This pattern can be applied when you want in a template to store a function and then invoke it later, with different paramters.</p>

<p>Same for lambda, when writing it, the programmer might simply not care what the p1 and p2 types are - they are deduced by the compiler given the way the function is invoked - in this case p1 is an <code class="highlighter-rouge">int</code> and p2 is a <code class="highlighter-rouge">const char*</code>. 
Note though, this check is performed at compile time, so it is not at all a form of dynamic invocation.</p>

<div class="language-csharp highlighter-rouge"><pre class="highlight"><code><span class="n">template</span><span class="p">&lt;</span><span class="n">typename</span> <span class="n">Fn</span><span class="p">,</span> <span class="n">typename</span><span class="p">...</span> <span class="n">T</span><span class="p">&gt;</span> <span class="k">void</span> <span class="nf">invoke</span><span class="p">(</span><span class="k">const</span> <span class="n">Fn</span><span class="p">&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="p">&amp;...</span> <span class="k">params</span><span class="p">){</span>
	<span class="nf">fn</span><span class="p">(</span><span class="k">params</span><span class="p">...);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">test_lambdas_cxx14</span><span class="p">()</span> <span class="p">{</span>

	<span class="n">auto</span> <span class="n">ptr</span> <span class="p">=</span> <span class="n">make_unique</span><span class="p">&lt;</span><span class="n">Test</span><span class="p">&gt;();</span>

	<span class="c1">// auto parameters for lambda, initialization for capture parameters (c++14)
</span>	<span class="nf">invoke</span><span class="p">(</span> <span class="p">[</span><span class="n">ptr</span> <span class="p">=</span> <span class="nf">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">)]</span> <span class="p">(</span><span class="n">auto</span> <span class="n">p1</span><span class="p">,</span> <span class="n">auto</span> <span class="n">p2</span><span class="p">){</span> 

		<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="n">ptr</span><span class="p">-&gt;</span><span class="n">str</span><span class="p">.</span><span class="nf">c_str</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="s">" "</span> <span class="p">&lt;&lt;</span> <span class="n">p1</span> <span class="p">&lt;&lt;</span> <span class="s">" "</span> <span class="p">&lt;&lt;</span> <span class="n">p2</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

	<span class="p">},</span> <span class="m">2</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">);</span>

	<span class="c1">// should be null because it was moved in the lambda initialization
</span>	<span class="n">cout</span> <span class="p">&lt;&lt;</span> <span class="s">"Value of ptr:"</span> <span class="p">&lt;&lt;</span>  <span class="n">ptr</span><span class="p">.</span><span class="k">get</span><span class="p">()</span> <span class="p">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

<span class="p">}</span>
</code></pre>
</div>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">From The Trenches - The Code</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              From The Trenches - The Code
            
            </li>
            
            <li><a href="mailto:alexandru.gris2006@gmail.com">alexandru.gris2006@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/alexandrugris"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/alexandrugris"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">alexandrugris</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Alexandru Gris - Personal Blog
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
